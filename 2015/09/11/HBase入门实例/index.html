<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="Data change world!" />



  <meta name="keywords" content="HBase," />



  <link rel="alternate" href="/atom.xml" title="Data change world" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="Table中Family和Qualifier的关系与区别就像用MySQL一样，我们要做的是表设计，MySQL中的表，行，列的在HBase已经有所区别了，在HBase中主要是Table和Family和Qualifier，这三个概念。Table可以直接理解为表，而Family和Qualifier其实都可以理解为列，一个Family下面可以有多个Qualifier，所以可以简单的理解为，HBase中的列">
<meta property="og:type" content="article">
<meta property="og:title" content="HBase入门实例">
<meta property="og:url" content="http://liuziquan.github.io/2015/09/11/HBase入门实例/index.html">
<meta property="og:site_name" content="Data change world">
<meta property="og:description" content="Table中Family和Qualifier的关系与区别就像用MySQL一样，我们要做的是表设计，MySQL中的表，行，列的在HBase已经有所区别了，在HBase中主要是Table和Family和Qualifier，这三个概念。Table可以直接理解为表，而Family和Qualifier其实都可以理解为列，一个Family下面可以有多个Qualifier，所以可以简单的理解为，HBase中的列">
<meta property="og:updated_time" content="2015-09-11T05:54:55.354Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HBase入门实例">
<meta name="twitter:description" content="Table中Family和Qualifier的关系与区别就像用MySQL一样，我们要做的是表设计，MySQL中的表，行，列的在HBase已经有所区别了，在HBase中主要是Table和Family和Qualifier，这三个概念。Table可以直接理解为表，而Family和Qualifier其实都可以理解为列，一个Family下面可以有多个Qualifier，所以可以简单的理解为，HBase中的列">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> HBase入门实例 | Data change world </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Data change world</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              HBase入门实例
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-09-11T00:00:00+08:00" content="2015-09-11">
            2015-09-11
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/HBase/" itemprop="url" rel="index">
                  <span itemprop="name">HBase</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><h2 id="Table中Family和Qualifier的关系与区别">Table中Family和Qualifier的关系与区别</h2><p>就像用MySQL一样，我们要做的是表设计，MySQL中的表，行，列的在HBase已经有所区别了，在HBase中主要是Table和Family和Qualifier，这三个概念。Table可以直接理解为表，而Family和Qualifier其实都可以理解为列，一个Family下面可以有多个Qualifier，所以可以简单的理解为，HBase中的列是二级列，也就是说Family是第一级列，Qualifier是第二级列。两个是父子关系。</p>
<h2 id="谈谈Table中Family和Qualifier的设置">谈谈Table中Family和Qualifier的设置</h2><p>对于传统关系型数据库中的一张table，在业务转换到hbase上建模时，从性能的角度应该如何设置family和qualifier呢？<br>最极端的，可以每一列都设置成一个family，也可以只有一个family，但所有列都是其中的一个qualifier，那么有什么区别呢？<br>family越多，那么获取每一个cell数据的优势越明显，因为io和网络都减少了，而如果只有一个family，那么每一次读都会读取当前rowkey的所有数据，网络和io上会有一些损失。<br>当然如果要获取的是固定的几列数据，那么把这几列写到一个family中比分别设置family要更好，因为只需一次请求就能拿回所有数据。<br>以上是从读的方面来考虑的，那么写呢？可以参考一下这篇文章：<br><a href="http://hbase.apache.org/book/number.of.cfs.html" target="_blank" rel="external">http://hbase.apache.org/book/number.of.cfs.html</a></p>
<p>首先，不同的family是在同一个region下面。而每一个family都会分配一个memstore，所以更多的family会消耗更多的内存。<br>其次,目前版本的hbase，在flush和compaction都是以region为单位的，也就是说当一个family达到flush条件时，该region的所有family所属的memstore都会flush一次，即使memstore中只有很少的数据也会触发flush而生成小文件。这样就增加了compaction发生的机率，而compaction也是以region为单位的，这样就很容易发生compaction风暴从而降低系统的整体吞吐量。<br>第三，由于hfile是以family为单位的，因此对于多个family来说，数据被分散到了更多的hfile中，减小了split发生的机率。这是把双刃剑。更少的split会导致该region的体积比较大，由于balance是以region的数目而不是大小为单位来进行的，因此可能会导致balance失效。而从好的方面来说，更少的split会让系统提供更加稳定的在线服务。<br>上述第三点的好处对于在线应用来说是明显的，而坏处我们可以通过在请求的低谷时间进行人工的split和balance来避免掉。<br>因此对于写比较多的系统，如果是离线应该，我们尽量只用一个family好了，但如果是在线应用，那还是应该根据应用的情况合理地分配family。</p>
<p>HBase实例代码</p>
<pre><code><span class="comment">/**
 * Hbase 基本CRUD 样例代码   覆盖Put Get Delete checkAndPut checkAndDelete  Scan
 * 通过上面的各种操作的例子, 会基本覆盖Htable可以用的的所有方法
 * 这里不涉及Hbase 管理代码的操作
 * @author Administrator
 *
 */</span>
public class HbaseCRUDTest_New {
    private static org.apache.hadoop.conf.Configuration conf = null;
    private static HTablePool pool = null;
    private static HBaseAdmin admin = null;
    private static final int MAX_TABLE_COUNT = <span class="number">10</span>;

    @BeforeClass
    public static void before<span class="params">()</span>throws Exception{
        <span class="comment">/**服务器端缓存客户端的连接 是以conf为单位的（可能不准确：通常一个客户端
         * 连接过来, 服务器端会有一个线程与之对应, 缓存的是这个服务器端的线程）,
         * 所以最好不要到处创建conf实例, 一个就够了, 所有共用conf创建的到Hbase
         * 的连接和操作, 会共用一个连接  这样可以提高性能, 也会减小服务器端的压力
         * 实际上创建Htable pool admin都是通过HConnection接口的实现类（
         * HConnectionImplementation）来完成的, 多个HConnection会由
         * HConnectionManager来管理, 而conf是HConnectionImplementation的最
         * 重要的构造参数 , 上面就以conf 来 标识和替代Hconnection 可能会带来歧义
         * 以为conf就是连接本身
         */</span>
        conf = HBaseConfiguration.create<span class="params">()</span>;
        <span class="comment">//这是一个10台集群的daily 日常性能测试环境</span>
        conf.set<span class="params">(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"10.232.31.209,10.232.31.210,10.232.31.211"</span>)</span>;
        conf.set<span class="params">(<span class="string">"hbase.zookeeper.property.clientPort"</span>, <span class="string">"3325"</span>)</span>;
        <span class="comment">//conf.addResource("dataSource.xml");//也可以载入一个标准的Hbase配置文件</span>

        <span class="comment">/**HTable是非线程安全的  在多线程环境下使用HTablePool是一个好的解决方案,
         * 参数MAX_TABLE_COUNT 是 pool保持的每个Htable实例的最大数量  ,
         * 比如为10   如果有100个线程getTable() 同一张表   则他们会共用 pool中的该
         * 表的10个实例   有些可能要排队等 用完的要回收放回去
         * 使用的时候 就不要new Htable了, 直接从pool中取
         * 用完再putTable 放回去
         *
         * 在0.92以上的版本  则不用放回去   直接table.close() 即可    putTable 被标记
         * 为 @Deprecated.  0.90.2 版本使用 putTable 下面的代码都没有 做 这些操作
         * 避免 不同版本 出问题
         */</span>
        pool = new HTablePool<span class="params">(conf, MAX_TABLE_COUNT)</span>;
        admin = new HBaseAdmin<span class="params">(conf)</span>;
    }
    <span class="comment">/**
     * 注意一下：Put Get Delete Scan等操作的对象 都提供一个空的构造函数, 一般不要直接使用, 
     *          他们存在主要是在rpc传输的反序列化的时候要用到（了解Java RMI的应该很清楚）
     * @throws IOException
     * @throws InterruptedException
     */</span>
    @Test public void putTest<span class="params">()</span> throws IOException, InterruptedException{
        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        <span class="comment">//批量操作 共两种 底层都是调用  HConnection的processBatch方法(</span>
        <span class="comment">// table.batch(List&lt;Put&gt;) 和table.flushCommits()会直接调用)</span>

        <span class="comment">//首先  自动flush 关闭    就像 JDBC中的 auto_commit,  否则 加每一条 提交</span>
        <span class="comment">// 一次,影响性能     不过table.put(List&lt;Put&gt;) table.batch(List&lt;Row&gt;)不受这</span>
        <span class="comment">// 个影响, 设置false,只有当put总大小超过writeBufferSize 才提交  或者手工</span>
        <span class="comment">// table.flushCommits() （table.put(List&lt;Put&gt;)操作完成后会手工提交一次）,</span>
        <span class="comment">// writeBufferSize 也可以调整</span>
        table.setAutoFlush<span class="params">(<span class="literal">false</span>)</span>;
        <span class="comment">//writeBufferSize 默认为2M ,调大可以增加批量处理的吞吐量, 丢失数据的风险也会加大</span>
        table.setWriteBufferSize<span class="params">(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">5</span>)</span>;
        <span class="comment">//这样可以看到 当前客户端缓存了多少put</span>
        ArrayList&lt;Put&gt; putx = table.getWriteBuffer<span class="params">()</span>;

        <span class="comment">// 批量操作方法一,单一操作的批量 比如Htable.put delete get 都提供了List作</span>
        <span class="comment">// 为参数的批处理.   默认每10条 或List&lt;Put&gt;数据量 超过writeBufferSize 提交</span>
        <span class="comment">// 如果AutoFlush为true 一次性table.put(List&lt;Put&gt;)只提交一次</span>
        List&lt;Put&gt; puts = new ArrayList&lt;Put&gt;<span class="params">(<span class="number">10</span>)</span>;

        <span class="keyword">for</span> <span class="params">(int i = <span class="number">0</span>,len=<span class="number">10</span>; i &lt; len; i++)</span> {
            Put put = new Put<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-"</span>+i)</span>,new Date<span class="params">()</span>.getTime<span class="params">()</span>)</span>;
            put.add<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"name"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"value"</span>+i)</span>)</span>;
            <span class="comment">// 这里可以自定义添加时间戳, 默认就是当前时间(RegionServer服务器端的</span>
            <span class="comment">// 时间) 也可以自己定义, 多版本时候(默认3)比如想插入一条比现在最新的记</span>
            <span class="comment">// 录老的, 一些特殊情况下可能会有这种需求</span>
            put.add<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"email"</span>)</span>, System.currentTimeMillis<span class="params">()</span>,
                    Bytes.toBytes<span class="params">(<span class="string">"value"</span>+i+<span class="string">"@sina.com"</span>)</span>)</span>;
            <span class="comment">//也可以直接加入一个KeyValue,实际上底层就是存储为KeyValue的, 如果对</span>
            <span class="comment">// 底层较熟悉, 这种操行更加高效, 一般上面的就可以完成日常工作了</span>
            put.add<span class="params">(new KeyValue<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-"</span>+i)</span>, Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>,
                    Bytes.toBytes<span class="params">(<span class="string">"age"</span>)</span>,Bytes.toBytes<span class="params">(<span class="number">20</span>+i)</span>)</span>)</span>;
            puts.add<span class="params">(put)</span>;

            <span class="comment">//写操作日志  这个对性能影响比较大,  但有很重要, 如果设为true, 只要写</span>
            <span class="comment">// 成功, 就算 机器挂掉 也不会丢失,</span>
            put.setWriteToWAL<span class="params">(<span class="literal">false</span>)</span>;
            <span class="comment">/**
             * Put还有一些额外的东西
             */</span>
            <span class="comment">//put.has(family, qualifier,ts,value)</span>
            <span class="comment">//put 当前在内存中的大小  这个在setWriteBufferSize 可能会用到</span>
            <span class="comment">/**实际上底层是 这么干的（当然还有其他比如put数量对table.flushCommits()的触发）
             * for(Put put:puts){
             *  total+=put.heapSize();
             *  if(total&gt;=table.getWriteBufferSize())
             *      table.flushCommits();
             * }
             */</span>
            put.heapSize<span class="params">()</span>;
            <span class="comment">//put 中 每次调用add 底层都会添加一个KeyValue,这个是添加的KeyValue数量</span>
            put.size<span class="params">()</span>;

            <span class="comment">//判断put中是否已经存在了 给定的family qualifier ts value</span>
<span class="comment">//          put.has(family, qualifier)</span>
<span class="comment">//          put.has(family, qualifier, value)</span>
<span class="comment">//          put.has(family, qualifier, ts)</span>
<span class="comment">//          put.has(family, qualifier, ts, value)</span>

            <span class="comment">//下面的方法 从字面上基本上就可以知道</span>
            put.isEmpty<span class="params">()</span>;
            put.getRow<span class="params">()</span>;
            put.getRowLock<span class="params">()</span>;
            put.getLockId<span class="params">()</span>;
            put.numFamilies<span class="params">()</span>;

        }

        table.put<span class="params">(puts)</span>;
        table.flushCommits<span class="params">()</span>;
        System.out.println<span class="params">(table.get<span class="params">(new Get<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-1"</span>)</span>)</span>)</span>)</span>;
        admin.flush<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        System.out.println<span class="params">(table.get<span class="params">(new Get<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-1"</span>)</span>)</span>)</span>)</span>;

        <span class="comment">//批量操作方法一, 使用batch,可以混合各种操作 ( Put Delete Get 都是接口Row的实现)</span>
        <span class="comment">//主要 这个如果处理Put操作 是不会使用客户端缓存的   会直接异步的发送到服务器端</span>
        List&lt;Row&gt; rows = new ArrayList&lt;Row&gt;<span class="params">(<span class="number">10</span>)</span>;
        <span class="keyword">for</span> <span class="params">(int i = <span class="number">10</span>,len=<span class="number">20</span>; i &lt; len; i++)</span> {
            Put put = new Put<span class="params">(Bytes.toBytes<span class="params">(<span class="params">(<span class="string">"row-"</span>+i)</span>)</span>)</span>;
            put.add<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"name"</span>)</span>, Bytes.toBytes<span class="params">(<span class="params">(<span class="string">"value"</span>+i)</span>)</span>)</span>;
            put.add<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"email"</span>)</span>, Bytes.toBytes<span class="params">(<span class="params">(<span class="string">"value"</span>+i+<span class="string">"@sina.com"</span>)</span>)</span>)</span>;
            rows.add<span class="params">(put)</span>;
        }
        <span class="comment">//可以添加 删除操作   但是 最好不要把对同一行的Put Delete用batch操作 ,</span>
        <span class="comment">// 因为 为了更好的性能  发到服务器端操作的顺序  是会改变的   很有可能不是放入的顺序</span>
        rows.add<span class="params">(new Delete<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-9"</span>)</span>)</span>)</span>;
        table.batch<span class="params">(rows)</span>;

            <span class="comment">/**  一些需要注意的地方：
             * 1. 提交到服务器  处理如果出现问题  会从服务器端返回RetriesExhaustedWithDetailsException
             * 包含出错的原因 和重试的次数
             * 如果 服务器端还是操作失败 , 这些put还会缓存在客户端  等到下次buffer 被flush,
             * 注意  如果客户端挂掉了   这些数据是会丢失的
             * 当然如果是NoSuchColumnFamilyException只会重试一次 并且不会恢复
             * 下面的情况要注意了
             * table.put(puts); 是会抛出异常的,而且不会再提交  这样数据会丢失的
             * 捕获这个异常手工table.flushCommits() 可以确保已经写入缓存的还可以有可能写入成功
             * try {
                    table.put(puts);
                } catch (Exception e) {
                    table.flushCommits();
                }
             * table.flushCommits(); 也会有异常   也要捕获
             *
             * 2. 还时候 启用缓存   正常操作发生异常时候并不会被正常报出来, 有时候
             * 会等到buffer被flush后才报出来  这也是要注意的地方
             *
             * 3.在缓存中的puts 被发送到服务器端的顺序和服务器处理的顺序 是控制不
             * 到的, 如果想指定顺序 , 只能使用较小的批处理  强制他们按照批处理的顺序执行
             */</span>

        <span class="comment">/**
         * 完备的一条记录就是一个KeyValue 一个rowkey可能有多个KeyValue（比如
         * 多个版本, 一个版本是一条）
         * rowkey ColumnFamily  Column  TimeStamp Type Value
         * 其中的Type就是区别Put和Delete等操作的类别, 实际上Delete也是添加一条记录
         * （Hbase存储的HDFS文件是只读的, 更新用 添加+删除 组合完成, 删除实际上
         * 也是添加一条删除,实际操作都是添加,在Hbase Compact时候 合并数据时候会剔除标记为删除的rowkey）
         * 这种 增 改 删的一致性操作  在客户端给我们的操作带来了便利
         *
         * 实际上ColumnFamily Column的名字是会以byte的形式存储在数据中的,
         * 因此, 它们在设计的时候名字应该尽可能的短 这样可以节省不少的空间
         */</span>
    }

    <span class="comment">/**
     * Delete与Put一致 把全部的Put改成Delete  table.put --&gt;table.delete 就可以了,
     * 不过有些需要注意, 看下面
     */</span>
    @Test public void deleteTest<span class="params">()</span>{
        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        try {
            <span class="comment">//如果上面介绍的KeyValue 有点印象, 通过delete提供的构造函数可以知道</span>
            <span class="comment">//不指定会删除所有的版本</span>
            Delete delete = new Delete<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-1"</span>)</span>)</span>;
            table.delete<span class="params">(delete)</span>;
        } catch <span class="params">(Exception e)</span> {
            e.printStackTrace<span class="params">()</span>;
        }
    }
    <span class="comment">/**
     * 一些原子性操作   对于java并发工具包有所了解的 应该会知道 轻量级锁的核心就是CAS机制(Compare and swap),
     * 这里在概念上有些类似, 也可以类似于  SQL中  select 出来然后   insert or update的 操作  
     * Hbase这里可以保证他们在一个原子操作
     * 这个在高并发 场景下  更新值  是个好的选择
     * table.checkAndPut(row, family, qualifier, value, put)
     * table.checkAndDelete(row, family, qualifier, value, delete)
     * @throws IOException
     */</span>
    @Test public void atomicOP<span class="params">()</span> throws IOException{
        byte[] row = Bytes.toBytes<span class="params">(<span class="string">"row-12"</span>)</span>;
        byte[] family = Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>;

        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        <span class="comment">//操作成功会返回 true,否则false;  如果是个不存在的qualifier, 把value置为null  check是会成功的</span>
        Put put = new Put<span class="params">(row)</span>;
        put.add<span class="params">(family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"value12"</span>)</span>)</span>;
        <span class="comment">//check 和put是同一个row</span>
        boolean result1 = table.checkAndPut<span class="params">(row, family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>, null, put)</span>;  <span class="comment">//true</span>
        boolean result2 = table.checkAndPut<span class="params">(row, family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>, null, put)</span>;   <span class="comment">//false</span>

        Put put2 = new Put<span class="params">(row)</span>;
        put2.add<span class="params">(family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"value12"</span>)</span>)</span>;
        boolean result3 = table.checkAndPut<span class="params">(row, family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>,
                Bytes.toBytes<span class="params">(<span class="string">"value12"</span>)</span>, put2)</span>;  <span class="comment">//true</span>

        Put put3 = new Put<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-13"</span>)</span>)</span>;
        put3.add<span class="params">(family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"value13"</span>)</span>)</span>;
        boolean result4 = table.checkAndPut<span class="params">(row, family, Bytes.toBytes<span class="params">(<span class="string">"namex2"</span>)</span>,
                Bytes.toBytes<span class="params">(<span class="string">"value12"</span>)</span>, put3)</span>;  <span class="comment">//org.apache.hadoop.hbase.DoNotRetryIOException</span>
        <span class="comment">//注意：check 和put的一定要是同一行 否则会报错</span>

<span class="comment">//      table.checkAndDelete类似</span>
    }

    <span class="comment">/**
     * 上面的一些操作有些方法可能涉及到Row Locks 但并没有说明   这里详细介绍下
     *
     * 一些会使数据发生变化的操作  比如like put(), delete(), checkAndPut()等等 , 操作都是以一个row为单位的,
     * 使用row lock 可以保证  一次性只能有一个客户端修改一个row
     * 虽然 实践中  客户端应用程序 并没有明确的使用lock, 但服务端会在适当的时机保护每一个独立的操作
     *
     * 如果可能应当尽量避免使用lock, 就像RSBMS一样会有死锁问题
     * @throws IOException
     */</span>
    @Test public void rowLocksTest<span class="params">()</span> throws IOException{
        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        byte[] row = Bytes.toBytes<span class="params">(<span class="string">"row-8"</span>)</span>;
        RowLock lock = table.lockRow<span class="params">(row)</span>;
        <span class="comment">//.....相关操作</span>
        table.unlockRow<span class="params">(lock)</span>;
        <span class="comment">//锁有效时间 默认时间是1分钟</span>
    }

    @SuppressWarnings<span class="params">(<span class="string">"deprecation"</span>)</span>
    @Test public void getTest<span class="params">()</span>{
        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        Get get = new Get<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-10"</span>)</span>)</span>;
        <span class="comment">//默认 get 只会取得最新的记录, 使用下面的方法可以获取其他的版本</span>
        <span class="comment">//有两个方法 一个带参数的可以指定版本数量, 可能会抛出异常;另外一个没有</span>
        <span class="comment">// 参数, 默认Integer.MAX_VALUE, 不会抛出异常</span>
        get.setMaxVersions<span class="params">()</span>;
    <span class="comment">//  get.setFilter(filter); get 一般数据比较少比较少使用filter, 在Scan的时候会详细介绍Filter</span>
        <span class="comment">//通过get.addColumn提供了各种重载方法, 可以过滤只获取哪些ColumnFamily</span>
        <span class="comment">// 和Column,get实现这种过滤只能使用这种方法, 接下来的Scan还可以使用Filter来实现</span>
        get.addColumn<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>,Bytes.toBytes<span class="params">(<span class="string">"email"</span>)</span>)</span>;

        try {
            Result result = table.get<span class="params">(get)</span>;
            <span class="comment">//这是一个简单的 获取返回结果的方法, 还有其他的通过遍历Map的方式</span>
            List&lt;KeyValue&gt; values = result.list<span class="params">()</span>;
            <span class="comment">//由于KeyValue靠近底层, 对于一些一些Offset,Length结尾的方法 可以忽略,</span>
            <span class="comment">// 比较感兴趣的可以关注下Hbase的底层存储</span>
            <span class="keyword">for</span> <span class="params">(KeyValue keyValue : values)</span> {
                StringBuilder sb = new StringBuilder<span class="params">(Bytes.toString<span class="params">(keyValue.getFamily<span class="params">()</span>)</span>)</span>;
                sb.append<span class="params">(<span class="string">":"</span>)</span>.append<span class="params">(Bytes.toString<span class="params">(keyValue.getQualifier<span class="params">()</span>)</span>)</span>.append<span class="params">(<span class="string">"--:"</span>)</span>;
                sb.append<span class="params">(Bytes.toString<span class="params">(keyValue.getValue<span class="params">()</span>)</span>)</span>.append<span class="params">(<span class="string">"  "</span>)</span>.append<span class="params">(
                        new Date<span class="params">(keyValue.getTimestamp<span class="params">()</span>)</span>.toLocaleString<span class="params">()</span>)</span>;
                System.out.println<span class="params">(sb.toString<span class="params">()</span>)</span>;
            }

            <span class="comment">//这是另外一种获取返回结果的方式, 这种在Scan的返回多个Result的时候</span>
            <span class="comment">// 相对实用, 一个rowkey的都在一起, 一个ColumnFamily的也聚合在一起</span>
            NavigableMap&lt;byte[], NavigableMap&lt;byte[], NavigableMap&lt;Long, byte[]&gt;&gt;&gt; nMap = result.getMap<span class="params">()</span>;
            <span class="keyword">for</span> <span class="params">(Map.Entry&lt;byte[], NavigableMap&lt;byte[], NavigableMap&lt;Long, byte[]&gt;&gt;&gt; entry:nMap.entrySet<span class="params">()</span> )</span> {
                <span class="comment">//entry.getKey()为family key</span>
                String family = Bytes.toString<span class="params">(entry.getKey<span class="params">()</span>)</span>;
                System.out.print<span class="params">(family+<span class="string">":"</span>)</span>;
                <span class="keyword">for</span> <span class="params">(Map.Entry&lt;byte[], NavigableMap&lt;Long, byte[]&gt;&gt; entry2 : entry.getValue<span class="params">()</span>.entrySet<span class="params">()</span> )</span> {
                    <span class="comment">// entry2.getKey()为qualifier  当然qualifier有可能为空  这个不是问题  但为null的只能有一个</span>
                    String qualifier = Bytes.toString<span class="params">(entry2.getKey<span class="params">()</span>)</span>;
                    System.out.print<span class="params">(qualifier+<span class="string">"--:"</span>)</span>;
                    <span class="keyword">for</span> <span class="params">(Map.Entry&lt;Long, byte[]&gt; entry3:entry2.getValue<span class="params">()</span>.entrySet<span class="params">()</span> )</span> {
                        <span class="comment">//entry3.getKey()为 timestamp  entry3.getValue()为 value</span>
                        System.out.print<span class="params">(Bytes.toString<span class="params">(entry3.getValue<span class="params">()</span>)</span>+<span class="string">" "</span>
                                +new Date<span class="params">(entry3.getKey<span class="params">()</span>)</span>.toLocaleString<span class="params">()</span>)</span>;
                    }
                }
            }
            System.out.println<span class="params">(<span class="string">"------------------"</span>)</span>;
            <span class="comment">//Get的批处理类似于 SQL中的in操作,但操作起来也相当的简单, 和上面</span>
            <span class="comment">// 的Put Delete非常类似,也可以混合使用</span>
            List&lt;Row&gt; rows = new ArrayList&lt;Row&gt;<span class="params">()</span>;
            rows.add<span class="params">(new Get<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-10"</span>)</span>)</span>)</span>;
            rows.add<span class="params">(new Get<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-11"</span>)</span>)</span>)</span>;
            rows.add<span class="params">(new Put<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-1222221"</span>)</span>)</span>)</span>;
            try {
                Object[] objs = table.batch<span class="params">(rows)</span>;
                <span class="keyword">for</span> <span class="params">(Object obj : objs)</span> {
                    printKeyValue<span class="params">(<span class="params">(Result)</span>obj)</span>;
                }
            } catch <span class="params">(InterruptedException e)</span> {
                e.printStackTrace<span class="params">()</span>;
            }

        } catch <span class="params">(IOException e)</span> {
            e.printStackTrace<span class="params">()</span>;
        }
        <span class="comment">/**
         * Get获取单个 或随机的几个row 使用起来非常方便, 对于访问多个连续的row
         * 使用下面将要介绍的Scan操作,通常情况下, 完成一个业务 需要多个操作, 而
         * ORM无法将一个业务所有的操作SQL封装在一起, 除非直接使用JDBC
         * Hbase的这种 Put Get Delete 是不是很棒 , 对了没有Update, update的就
         * 是新增一条, 由于有版本, 旧的不会被立即淘汰掉
         */</span>
    }

    public void printKeyValue<span class="params">(Result result)</span>{
        List&lt;KeyValue&gt; values = result.list<span class="params">()</span>;
        <span class="comment">//由于KeyValue靠近底层, 对于一些一些Offset,Length结尾的方法 可以忽略,</span>
        <span class="comment">// 比较感兴趣的可以关注下Hbase的底层存储</span>
        <span class="keyword">for</span> <span class="params">(KeyValue keyValue : values)</span> {
            StringBuilder sb = new StringBuilder<span class="params">(Bytes.toString<span class="params">(keyValue.getFamily<span class="params">()</span>)</span>)</span>;
            sb.append<span class="params">(<span class="string">":"</span>)</span>.append<span class="params">(Bytes.toString<span class="params">(keyValue.getQualifier<span class="params">()</span>)</span>)</span>.append<span class="params">(<span class="string">"--:"</span>)</span>;
            sb.append<span class="params">(Bytes.toString<span class="params">(keyValue.getValue<span class="params">()</span>)</span>)</span>.append<span class="params">(<span class="string">"  "</span>)</span>.append<span class="params">(
                    new Date<span class="params">(keyValue.getTimestamp<span class="params">()</span>)</span>.toLocaleString<span class="params">()</span>)</span>;
            System.out.println<span class="params">(sb.toString<span class="params">()</span>)</span>;
        }
    }

    <span class="comment">/**
     * 对于连续记录的顺序访问  就是类似于 最常见的Select操作
     * 实际上Scan 非常类似于Hibernate 的DetachedCriteria, 而scan 使用的Filter就相当于Criteria的Expression或Restrictions
     * 可以实现离线封装查询条件   这个是相当的给力啊
     */</span>
    @Test public void ScanTest<span class="params">()</span>{
        ResultScanner resultScanner = null;
        try {
            <span class="comment">/**
             * 如Scan的名字, Scan是在一定的范围内startkey(StartRow)和endkey(StopRow)
             * 之间 顺序的扫描, 配合Filter 可以跳过不满足条件的记录  返回需要的结果
             * 当然startkey和endkey只是标识一个范围, 它们对应的rowkey可能并不存在,
             * 但如果存在(startkey) 扫描的范围是[startkey,endkey),否则就是(startkey,endkey)
             * 可以看到 Scan 有一个包裹Get的构造, 可以利用该get的rowkey作为startkey
             */</span>
            Scan scan  = new Scan<span class="params">()</span>;

            <span class="comment">/**
             * ResultScanner 就是table scanner返回的结果集, 类似于游标 可以迭代获取结果,
             * batch 就是每次迭代从服务器获取的记录数, 设置太小 会频繁到服务器取数据,
             * 太大 会对客户端造成比较大的压力,  具体根据需要使用 , 正常使用可以不必管
             * 它, 大批量读取可以考虑用它改善性能
             * 这里要注意了： 这个记录数是qualifier不是row, 如果一个row有17个qualifier,
             * setBatch(5),一个row就会分散到4个Result中, 分别持有5,5,5,2个qualifier
             * （默认一个row的所有qualifier会在一个Result中）
             *
             * ColumnPaginationFilter 对于一个Row会在一个Result 但是只返回前面一部分
             *
             * 如果使用FirstKeyOnlyFilter等 不是扫描Row全部的Filter 会有冲突 会有异常抛出 */</span>
            scan.setBatch<span class="params">(<span class="number">10</span>)</span>;
            <span class="comment">/**发给scanners的缓存的Row的数量, 如果没有设置会使用 HTable#getScannerCaching()的值
             * 一般 越大 Scan速度越快, 但消耗的内存也越大*/</span>
            scan.setCaching<span class="params">(<span class="number">10</span>)</span>;
            <span class="comment">//简而言之就是  batch 是qualifier column级别的   caching是row级别的</span>

            <span class="comment">//RegionServer是否应当缓存 当前客户端访问过的数据块    如果是随机的get 这个最好为false</span>
            scan.setCacheBlocks<span class="params">(<span class="literal">true</span>)</span>;

            <span class="comment">/** Scan 最复杂, 也最有用的就是Filter, 特别是FilterList对Filter进行的组合
             * 这里只先介绍Scan的其他参数 ;对于Filter,后面会单独介绍*/</span>

            <span class="comment">//startrow和stoprow 可以改变</span>
            scan.setStartRow<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-12"</span>)</span>)</span>;
            scan.setStopRow<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-1110"</span>)</span>)</span>;
            scan.setMaxVersions<span class="params">(<span class="number">3</span>)</span>;<span class="comment">//同Get</span>
            <span class="comment">/** 可以指定一个时间范围, 扫描指定时间或时间范围的的记录,  */</span>
            scan.setTimeRange<span class="params">(System.currentTimeMillis<span class="params">()</span>-<span class="number">1000000</span>, System.currentTimeMillis<span class="params">()</span>)</span>;
            <span class="comment">/**
             * 也可以指定timestamp 查询
             */</span>
            scan.setTimeStamp<span class="params">(System.currentTimeMillis<span class="params">()</span>)</span>;

            <span class="comment">/**可以使用Get中类似的方法 来限制获取的ColumnFamily Column*/</span>
            scan.addColumn<span class="params">(Bytes.toBytes<span class="params">(<span class="string">""</span>)</span>,Bytes.toBytes<span class="params">(<span class="string">""</span>)</span>)</span>;

            <span class="comment">//Scan中使用最多的还是Filter</span>
            HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
            <span class="comment">//看下面</span>
            table.setScannerCaching<span class="params">(<span class="number">1000</span>)</span>;
            resultScanner = table.getScanner<span class="params">(scan)</span>;
            <span class="comment">//这是foreach格式    是调用resultScanner.next()的</span>
            <span class="comment">//默认情况下  每次调用next() 都要RPC一下服务器   每个row一次, 即时resultScanner(int nbRows)</span>
            <span class="comment">//table.setScannerCaching() 默认是1  可以手工设置  设置后 该table实例的所有scan都有效</span>
            <span class="comment">//也可以每个scan单设置定就是上面有说过的scan.setCaching(1024*10); 这个会覆盖table设置的值</span>
            <span class="keyword">for</span> <span class="params">(Result result : resultScanner)</span> {
                <span class="comment">//这里就不多说了   和Get中一样的解析</span>
            }

        } catch <span class="params">(IOException e)</span> {
            e.printStackTrace<span class="params">()</span>;
        }finally{
            <span class="comment">//这样一定要记住 用完close</span>
            <span class="keyword">if</span><span class="params">(resultScanner!=null)</span>resultScanner.close<span class="params">()</span>;
        }

    }

    <span class="comment">/**
     * 高级的Scan,就是Filter中的FilterList  可以组合各个Filter
     * select cf1.column1,cf2.column2* from table_name where rowkey&gt;10 or value like 'xxx%' limit 10
     * 如果上面的SQL解析出来 and 表示MUST_PASS_ALL, or 表示MUST_PASS_ONE
     * 就是下面这个样(虽然理解可能不同,但下图的代码如下：)
     *  ( (cf1 and column1) or (cf2 and column2*)  ) and (rowkey&gt;10 or value like 'xxx%')
     * setFilter(
     *                                                        -ColumnFamilyFilter  cf1
     *                                     -filterList(ALL)--|
     *                                    |                   -ColumnFilter   column1
     *                  -filterList(ONE)-&gt;|
     *                 |                  |                   -ColumnFamilyFilter cf2
     *                 |                   -filterList(ALL)--|
     *                 |                                      -ColumnPrefixFilter column2
     *filterList(ALL)-&gt;|                -RowFilter 10
     *                 |-filterList(ONE)-&gt;|
     *                 |                   -ValueFilter xx
     *                  -PageFilter 10
     * @author Administrator
     *
     */</span>
    @Test public void scanAdvance<span class="params">()</span>{
        Scan scan  = new Scan<span class="params">()</span>;
        List&lt;Filter&gt; rootList = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
            List&lt;Filter&gt; selectList = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
                List&lt;Filter&gt; select_1 = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
                    select_1.add<span class="params">(new FamilyFilter<span class="params">(CompareFilter.CompareOp.EQUAL,
                            new BinaryComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"cf1"</span>)</span>)</span>)</span>)</span>;
                    select_1.add<span class="params">(new QualifierFilter<span class="params">(CompareFilter.CompareOp.EQUAL,
                            new BinaryComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"column1"</span>)</span>)</span>)</span>)</span>;
                List&lt;Filter&gt; select_2 = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
                    select_2.add<span class="params">(new FamilyFilter<span class="params">(CompareFilter.CompareOp.EQUAL,
                            new BinaryComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"cf2"</span>)</span>)</span>)</span>)</span>;
                    select_2.add<span class="params">(new QualifierFilter<span class="params">(CompareFilter.CompareOp.EQUAL,
                            new BinaryPrefixComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"column"</span>)</span>)</span>)</span>)</span>;
            selectList.add<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ALL, select_1)</span>)</span>;
            selectList.add<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ALL, select_2)</span>)</span>;
        rootList.add<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ONE,selectList)</span>)</span>;

            List&lt;Filter&gt; whereList = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
                whereList.add<span class="params">(new RowFilter<span class="params">(CompareFilter.CompareOp.GREATER,
                        new BinaryComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="number">10</span>)</span>)</span>)</span>)</span>;
                whereList.add<span class="params">(new RowFilter<span class="params">(CompareFilter.CompareOp.EQUAL,
                        new BinaryPrefixComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"xxx"</span>)</span>)</span>)</span>)</span>;
        rootList.add<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ONE,whereList)</span>)</span>;
        scan.setFilter<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ALL, rootList)</span>)</span>;
        <span class="comment">//这样的嵌套 写起来着实很烦, 可以自己封装成程序</span>
    }

    <span class="comment">/**
     * 一个不得不说的操作  分页操作, 
     * RDBMS 比如mysql :select * from table_name where sss=sss limit 1 10;
     * oracle 利用rownum也可以迂回实现,
     * Hbase这方面支持的不是太好, 也可以支持翻页
     */</span>
    @Test public void pageTest<span class="params">()</span>{
        <span class="comment">//与传统的分页的不同  start 是个起始的row  而不是一个数字 ,   下一页 的时候</span>
        <span class="comment">// 需要将上一页的最后一条记录作为分页条件传回来</span>
        <span class="comment">//这个start要是byte[],页面上只能暂时保存字符串  怎么办呢？？</span>
        <span class="comment">//Bytes.toStringBinary(byte[])与Bytes.toBytesBinary(String) 可以完美的实现字符串和byte[]的相互转换</span>
        <span class="comment">// Bytes.toStringBinary(Bytes.toBytesBinary("abc")) equals "abc" 是true</span>
        byte[] start = Bytes.toBytes<span class="params">(<span class="string">"row-13"</span>)</span>;
        int limit = <span class="number">10</span>;
        Scan scan = new Scan<span class="params">()</span>;
        scan.setStartRow<span class="params">(start)</span>;

        List&lt;Filter&gt; rootList = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
        rootList.add<span class="params">(new PageFilter<span class="params">(limit)</span>)</span>;
        <span class="comment">////root.add(new Filter()) 添加其他的过滤条件</span>

        scan.setFilter<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ALL, rootList)</span>)</span>;
    }

    <span class="comment">/**除了上面用到的
     * Htable 还有一些其他的有用方法
     * @throws IOException
     */</span>
    @SuppressWarnings<span class="params">(<span class="string">"unused"</span>)</span>
    @Test public void htableOthers<span class="params">()</span> throws IOException{
        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        byte [] row = Bytes.toBytes<span class="params">(<span class="string">"row-13"</span>)</span>;
        <span class="comment">//获取指定row的 数据所在的Region的信息 ：名字, 编码后名字(Hadoop 中的</span>
        <span class="comment">// 路径名), startKey endkey等---&gt;hri  ；还有该Region所在的主机的地址信息---&gt;addr</span>
        HRegionLocation hrl = table.getRegionLocation<span class="params">(row)</span>;
        HRegionInfo hri= hrl.getRegionInfo<span class="params">()</span>;
        HServerAddress addr = hrl.getServerAddress<span class="params">()</span>;

        <span class="comment">//获取所有Region的信息</span>
        Map&lt;HRegionInfo,HServerAddress&gt; regions = table.getRegionsInfo<span class="params">()</span>;

        <span class="comment">//获取该表所在的所有Region的  startKey 和 endKey</span>
        Pair&lt;byte[][], byte[][]&gt; startendKeys = table.getStartEndKeys<span class="params">()</span>;
        <span class="comment">//下面的是通过上面的实现的</span>
        table.getStartKeys<span class="params">()</span>;
        table.getEndKeys<span class="params">()</span>;

        <span class="comment">//table.getRowOrBefore(row, family) 这个一般用不到  0.92时候 就要被废弃了</span>
    }

    <span class="comment">/**
     * 操作完成后, 清理下资源还是很有必要的,
     * 在系统的ServletContextListener
     */</span>
    @AfterClass
    public static void after<span class="params">()</span>{
        try {
            <span class="keyword">if</span><span class="params">(conf!=null)</span> HConnectionManager.deleteConnection<span class="params">(conf, <span class="literal">false</span>)</span>;
            <span class="keyword">if</span><span class="params">(pool!=null)</span>pool.close<span class="params">()</span>;
        } catch <span class="params">(IOException e)</span> {
            e.printStackTrace<span class="params">()</span>;
        }
    }
}
        <span class="comment">// 路径名), startKey endkey等---&gt;hri  ；还有该Region所在的主机的地址信息---&gt;addr</span>
        HRegionLocation hrl = table.getRegionLocation<span class="params">(row)</span>;
        HRegionInfo hri= hrl.getRegionInfo<span class="params">()</span>;
        HServerAddress addr = hrl.getServerAddress<span class="params">()</span>;

        <span class="comment">//获取所有Region的信息</span>
        Map&lt;HRegionInfo,HServerAddress&gt; regions = table.getRegionsInfo<span class="params">()</span>;

        <span class="comment">//获取该表所在的所有Region的  startKey 和 endKey</span>
        Pair&lt;byte[][], byte[][]&gt; starten
</code></pre></span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/HBase/" rel="tag">#HBase</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/09/11/HBase应用之Table设计/" rel="prev">HBase应用之Table设计</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/09/02/hello-world/" rel="next">Hello World</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
          </div>
        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="liuziquan" itemprop="image"/>
          <p class="site-author-name" itemprop="name">liuziquan</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Data change world!</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Table中Family和Qualifier的关系与区别"><span class="nav-number">1.</span> <span class="nav-text">Table中Family和Qualifier的关系与区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈Table中Family和Qualifier的设置"><span class="nav-number">2.</span> <span class="nav-text">谈谈Table中Family和Qualifier的设置</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liuziquan</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.1" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
