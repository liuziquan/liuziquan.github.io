
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Category: HBase | Data change world</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- Set render engine for 360 browser -->
  <meta name="renderer" content="webkit">
  <!-- No Baidu Siteapp-->
  <meta http-equiv="Cache-Control" content="no-siteapp"/>
  <meta name="description" content="Data change world!">
<meta property="og:type" content="website">
<meta property="og:title" content="Data change world">
<meta property="og:url" content="http://liuziquan.github.io/categories/HBase/index.html">
<meta property="og:site_name" content="Data change world">
<meta property="og:description" content="Data change world!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Data change world">
<meta name="twitter:description" content="Data change world!">
  
  
    <link rel="icon" href="/img/logo.png">
    <meta name="mobile-web-app-capable" content="yes">
    <!-- Add to homescreen for Chrome on Android -->    
    <link rel="icon" sizes="192x192" href="/img/logo.png">
    <!-- Add to homescreen for Safari on iOS -->
    <link rel="apple-touch-icon-precomposed" href="/img/logo.png">    
    <!-- Tile icon for Win8 (144x144 + tile color) -->
    <meta name="msapplication-TileImage" content="/img/logo.png">
    <meta name="msapplication-TileColor" content="#0e90d2">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Data change world</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Anything can be quantified</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">文章</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <!--
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="liuziquan.github.io">
        </form>
      </div>
      -->
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-HBase入门实例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/11/HBase入门实例/" class="article-date">
  <time datetime="2015-09-10T16:00:00.000Z" itemprop="datePublished">2015-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/HBase/">HBase</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/11/HBase入门实例/">HBase入门实例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      

<!-- Table of Contents -->


        <h2 id="Table中Family和Qualifier的关系与区别">Table中Family和Qualifier的关系与区别</h2><p>就像用MySQL一样，我们要做的是表设计，MySQL中的表，行，列的在HBase已经有所区别了，在HBase中主要是Table和Family和Qualifier，这三个概念。Table可以直接理解为表，而Family和Qualifier其实都可以理解为列，一个Family下面可以有多个Qualifier，所以可以简单的理解为，HBase中的列是二级列，也就是说Family是第一级列，Qualifier是第二级列。两个是父子关系。</p>
<h2 id="谈谈Table中Family和Qualifier的设置">谈谈Table中Family和Qualifier的设置</h2><p>对于传统关系型数据库中的一张table，在业务转换到hbase上建模时，从性能的角度应该如何设置family和qualifier呢？<br>最极端的，可以每一列都设置成一个family，也可以只有一个family，但所有列都是其中的一个qualifier，那么有什么区别呢？<br>family越多，那么获取每一个cell数据的优势越明显，因为io和网络都减少了，而如果只有一个family，那么每一次读都会读取当前rowkey的所有数据，网络和io上会有一些损失。<br>当然如果要获取的是固定的几列数据，那么把这几列写到一个family中比分别设置family要更好，因为只需一次请求就能拿回所有数据。<br>以上是从读的方面来考虑的，那么写呢？可以参考一下这篇文章：<br><a href="http://hbase.apache.org/book/number.of.cfs.html" target="_blank" rel="external">http://hbase.apache.org/book/number.of.cfs.html</a></p>
<p>首先，不同的family是在同一个region下面。而每一个family都会分配一个memstore，所以更多的family会消耗更多的内存。<br>其次,目前版本的hbase，在flush和compaction都是以region为单位的，也就是说当一个family达到flush条件时，该region的所有family所属的memstore都会flush一次，即使memstore中只有很少的数据也会触发flush而生成小文件。这样就增加了compaction发生的机率，而compaction也是以region为单位的，这样就很容易发生compaction风暴从而降低系统的整体吞吐量。<br>第三，由于hfile是以family为单位的，因此对于多个family来说，数据被分散到了更多的hfile中，减小了split发生的机率。这是把双刃剑。更少的split会导致该region的体积比较大，由于balance是以region的数目而不是大小为单位来进行的，因此可能会导致balance失效。而从好的方面来说，更少的split会让系统提供更加稳定的在线服务。<br>上述第三点的好处对于在线应用来说是明显的，而坏处我们可以通过在请求的低谷时间进行人工的split和balance来避免掉。<br>因此对于写比较多的系统，如果是离线应该，我们尽量只用一个family好了，但如果是在线应用，那还是应该根据应用的情况合理地分配family。</p>
<p>HBase实例代码</p>
<pre><code><span class="comment">/**
 * Hbase 基本CRUD 样例代码   覆盖Put Get Delete checkAndPut checkAndDelete  Scan
 * 通过上面的各种操作的例子, 会基本覆盖Htable可以用的的所有方法
 * 这里不涉及Hbase 管理代码的操作
 * @author Administrator
 *
 */</span>
public class HbaseCRUDTest_New {
    private static org.apache.hadoop.conf.Configuration conf = null;
    private static HTablePool pool = null;
    private static HBaseAdmin admin = null;
    private static final int MAX_TABLE_COUNT = <span class="number">10</span>;

    @BeforeClass
    public static void before<span class="params">()</span>throws Exception{
        <span class="comment">/**服务器端缓存客户端的连接 是以conf为单位的（可能不准确：通常一个客户端
         * 连接过来, 服务器端会有一个线程与之对应, 缓存的是这个服务器端的线程）,
         * 所以最好不要到处创建conf实例, 一个就够了, 所有共用conf创建的到Hbase
         * 的连接和操作, 会共用一个连接  这样可以提高性能, 也会减小服务器端的压力
         * 实际上创建Htable pool admin都是通过HConnection接口的实现类（
         * HConnectionImplementation）来完成的, 多个HConnection会由
         * HConnectionManager来管理, 而conf是HConnectionImplementation的最
         * 重要的构造参数 , 上面就以conf 来 标识和替代Hconnection 可能会带来歧义
         * 以为conf就是连接本身
         */</span>
        conf = HBaseConfiguration.create<span class="params">()</span>;
        <span class="comment">//这是一个10台集群的daily 日常性能测试环境</span>
        conf.set<span class="params">(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"10.232.31.209,10.232.31.210,10.232.31.211"</span>)</span>;
        conf.set<span class="params">(<span class="string">"hbase.zookeeper.property.clientPort"</span>, <span class="string">"3325"</span>)</span>;
        <span class="comment">//conf.addResource("dataSource.xml");//也可以载入一个标准的Hbase配置文件</span>

        <span class="comment">/**HTable是非线程安全的  在多线程环境下使用HTablePool是一个好的解决方案,
         * 参数MAX_TABLE_COUNT 是 pool保持的每个Htable实例的最大数量  ,
         * 比如为10   如果有100个线程getTable() 同一张表   则他们会共用 pool中的该
         * 表的10个实例   有些可能要排队等 用完的要回收放回去
         * 使用的时候 就不要new Htable了, 直接从pool中取
         * 用完再putTable 放回去
         *
         * 在0.92以上的版本  则不用放回去   直接table.close() 即可    putTable 被标记
         * 为 @Deprecated.  0.90.2 版本使用 putTable 下面的代码都没有 做 这些操作
         * 避免 不同版本 出问题
         */</span>
        pool = new HTablePool<span class="params">(conf, MAX_TABLE_COUNT)</span>;
        admin = new HBaseAdmin<span class="params">(conf)</span>;
    }
    <span class="comment">/**
     * 注意一下：Put Get Delete Scan等操作的对象 都提供一个空的构造函数, 一般不要直接使用, 
     *          他们存在主要是在rpc传输的反序列化的时候要用到（了解Java RMI的应该很清楚）
     * @throws IOException
     * @throws InterruptedException
     */</span>
    @Test public void putTest<span class="params">()</span> throws IOException, InterruptedException{
        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        <span class="comment">//批量操作 共两种 底层都是调用  HConnection的processBatch方法(</span>
        <span class="comment">// table.batch(List&lt;Put&gt;) 和table.flushCommits()会直接调用)</span>

        <span class="comment">//首先  自动flush 关闭    就像 JDBC中的 auto_commit,  否则 加每一条 提交</span>
        <span class="comment">// 一次,影响性能     不过table.put(List&lt;Put&gt;) table.batch(List&lt;Row&gt;)不受这</span>
        <span class="comment">// 个影响, 设置false,只有当put总大小超过writeBufferSize 才提交  或者手工</span>
        <span class="comment">// table.flushCommits() （table.put(List&lt;Put&gt;)操作完成后会手工提交一次）,</span>
        <span class="comment">// writeBufferSize 也可以调整</span>
        table.setAutoFlush<span class="params">(<span class="literal">false</span>)</span>;
        <span class="comment">//writeBufferSize 默认为2M ,调大可以增加批量处理的吞吐量, 丢失数据的风险也会加大</span>
        table.setWriteBufferSize<span class="params">(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">5</span>)</span>;
        <span class="comment">//这样可以看到 当前客户端缓存了多少put</span>
        ArrayList&lt;Put&gt; putx = table.getWriteBuffer<span class="params">()</span>;

        <span class="comment">// 批量操作方法一,单一操作的批量 比如Htable.put delete get 都提供了List作</span>
        <span class="comment">// 为参数的批处理.   默认每10条 或List&lt;Put&gt;数据量 超过writeBufferSize 提交</span>
        <span class="comment">// 如果AutoFlush为true 一次性table.put(List&lt;Put&gt;)只提交一次</span>
        List&lt;Put&gt; puts = new ArrayList&lt;Put&gt;<span class="params">(<span class="number">10</span>)</span>;

        <span class="keyword">for</span> <span class="params">(int i = <span class="number">0</span>,len=<span class="number">10</span>; i &lt; len; i++)</span> {
            Put put = new Put<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-"</span>+i)</span>,new Date<span class="params">()</span>.getTime<span class="params">()</span>)</span>;
            put.add<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"name"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"value"</span>+i)</span>)</span>;
            <span class="comment">// 这里可以自定义添加时间戳, 默认就是当前时间(RegionServer服务器端的</span>
            <span class="comment">// 时间) 也可以自己定义, 多版本时候(默认3)比如想插入一条比现在最新的记</span>
            <span class="comment">// 录老的, 一些特殊情况下可能会有这种需求</span>
            put.add<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"email"</span>)</span>, System.currentTimeMillis<span class="params">()</span>,
                    Bytes.toBytes<span class="params">(<span class="string">"value"</span>+i+<span class="string">"@sina.com"</span>)</span>)</span>;
            <span class="comment">//也可以直接加入一个KeyValue,实际上底层就是存储为KeyValue的, 如果对</span>
            <span class="comment">// 底层较熟悉, 这种操行更加高效, 一般上面的就可以完成日常工作了</span>
            put.add<span class="params">(new KeyValue<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-"</span>+i)</span>, Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>,
                    Bytes.toBytes<span class="params">(<span class="string">"age"</span>)</span>,Bytes.toBytes<span class="params">(<span class="number">20</span>+i)</span>)</span>)</span>;
            puts.add<span class="params">(put)</span>;

            <span class="comment">//写操作日志  这个对性能影响比较大,  但有很重要, 如果设为true, 只要写</span>
            <span class="comment">// 成功, 就算 机器挂掉 也不会丢失,</span>
            put.setWriteToWAL<span class="params">(<span class="literal">false</span>)</span>;
            <span class="comment">/**
             * Put还有一些额外的东西
             */</span>
            <span class="comment">//put.has(family, qualifier,ts,value)</span>
            <span class="comment">//put 当前在内存中的大小  这个在setWriteBufferSize 可能会用到</span>
            <span class="comment">/**实际上底层是 这么干的（当然还有其他比如put数量对table.flushCommits()的触发）
             * for(Put put:puts){
             *  total+=put.heapSize();
             *  if(total&gt;=table.getWriteBufferSize())
             *      table.flushCommits();
             * }
             */</span>
            put.heapSize<span class="params">()</span>;
            <span class="comment">//put 中 每次调用add 底层都会添加一个KeyValue,这个是添加的KeyValue数量</span>
            put.size<span class="params">()</span>;

            <span class="comment">//判断put中是否已经存在了 给定的family qualifier ts value</span>
<span class="comment">//          put.has(family, qualifier)</span>
<span class="comment">//          put.has(family, qualifier, value)</span>
<span class="comment">//          put.has(family, qualifier, ts)</span>
<span class="comment">//          put.has(family, qualifier, ts, value)</span>

            <span class="comment">//下面的方法 从字面上基本上就可以知道</span>
            put.isEmpty<span class="params">()</span>;
            put.getRow<span class="params">()</span>;
            put.getRowLock<span class="params">()</span>;
            put.getLockId<span class="params">()</span>;
            put.numFamilies<span class="params">()</span>;

        }

        table.put<span class="params">(puts)</span>;
        table.flushCommits<span class="params">()</span>;
        System.out.println<span class="params">(table.get<span class="params">(new Get<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-1"</span>)</span>)</span>)</span>)</span>;
        admin.flush<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        System.out.println<span class="params">(table.get<span class="params">(new Get<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-1"</span>)</span>)</span>)</span>)</span>;

        <span class="comment">//批量操作方法一, 使用batch,可以混合各种操作 ( Put Delete Get 都是接口Row的实现)</span>
        <span class="comment">//主要 这个如果处理Put操作 是不会使用客户端缓存的   会直接异步的发送到服务器端</span>
        List&lt;Row&gt; rows = new ArrayList&lt;Row&gt;<span class="params">(<span class="number">10</span>)</span>;
        <span class="keyword">for</span> <span class="params">(int i = <span class="number">10</span>,len=<span class="number">20</span>; i &lt; len; i++)</span> {
            Put put = new Put<span class="params">(Bytes.toBytes<span class="params">(<span class="params">(<span class="string">"row-"</span>+i)</span>)</span>)</span>;
            put.add<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"name"</span>)</span>, Bytes.toBytes<span class="params">(<span class="params">(<span class="string">"value"</span>+i)</span>)</span>)</span>;
            put.add<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"email"</span>)</span>, Bytes.toBytes<span class="params">(<span class="params">(<span class="string">"value"</span>+i+<span class="string">"@sina.com"</span>)</span>)</span>)</span>;
            rows.add<span class="params">(put)</span>;
        }
        <span class="comment">//可以添加 删除操作   但是 最好不要把对同一行的Put Delete用batch操作 ,</span>
        <span class="comment">// 因为 为了更好的性能  发到服务器端操作的顺序  是会改变的   很有可能不是放入的顺序</span>
        rows.add<span class="params">(new Delete<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-9"</span>)</span>)</span>)</span>;
        table.batch<span class="params">(rows)</span>;

            <span class="comment">/**  一些需要注意的地方：
             * 1. 提交到服务器  处理如果出现问题  会从服务器端返回RetriesExhaustedWithDetailsException
             * 包含出错的原因 和重试的次数
             * 如果 服务器端还是操作失败 , 这些put还会缓存在客户端  等到下次buffer 被flush,
             * 注意  如果客户端挂掉了   这些数据是会丢失的
             * 当然如果是NoSuchColumnFamilyException只会重试一次 并且不会恢复
             * 下面的情况要注意了
             * table.put(puts); 是会抛出异常的,而且不会再提交  这样数据会丢失的
             * 捕获这个异常手工table.flushCommits() 可以确保已经写入缓存的还可以有可能写入成功
             * try {
                    table.put(puts);
                } catch (Exception e) {
                    table.flushCommits();
                }
             * table.flushCommits(); 也会有异常   也要捕获
             *
             * 2. 还时候 启用缓存   正常操作发生异常时候并不会被正常报出来, 有时候
             * 会等到buffer被flush后才报出来  这也是要注意的地方
             *
             * 3.在缓存中的puts 被发送到服务器端的顺序和服务器处理的顺序 是控制不
             * 到的, 如果想指定顺序 , 只能使用较小的批处理  强制他们按照批处理的顺序执行
             */</span>

        <span class="comment">/**
         * 完备的一条记录就是一个KeyValue 一个rowkey可能有多个KeyValue（比如
         * 多个版本, 一个版本是一条）
         * rowkey ColumnFamily  Column  TimeStamp Type Value
         * 其中的Type就是区别Put和Delete等操作的类别, 实际上Delete也是添加一条记录
         * （Hbase存储的HDFS文件是只读的, 更新用 添加+删除 组合完成, 删除实际上
         * 也是添加一条删除,实际操作都是添加,在Hbase Compact时候 合并数据时候会剔除标记为删除的rowkey）
         * 这种 增 改 删的一致性操作  在客户端给我们的操作带来了便利
         *
         * 实际上ColumnFamily Column的名字是会以byte的形式存储在数据中的,
         * 因此, 它们在设计的时候名字应该尽可能的短 这样可以节省不少的空间
         */</span>
    }

    <span class="comment">/**
     * Delete与Put一致 把全部的Put改成Delete  table.put --&gt;table.delete 就可以了,
     * 不过有些需要注意, 看下面
     */</span>
    @Test public void deleteTest<span class="params">()</span>{
        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        try {
            <span class="comment">//如果上面介绍的KeyValue 有点印象, 通过delete提供的构造函数可以知道</span>
            <span class="comment">//不指定会删除所有的版本</span>
            Delete delete = new Delete<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-1"</span>)</span>)</span>;
            table.delete<span class="params">(delete)</span>;
        } catch <span class="params">(Exception e)</span> {
            e.printStackTrace<span class="params">()</span>;
        }
    }
    <span class="comment">/**
     * 一些原子性操作   对于java并发工具包有所了解的 应该会知道 轻量级锁的核心就是CAS机制(Compare and swap),
     * 这里在概念上有些类似, 也可以类似于  SQL中  select 出来然后   insert or update的 操作  
     * Hbase这里可以保证他们在一个原子操作
     * 这个在高并发 场景下  更新值  是个好的选择
     * table.checkAndPut(row, family, qualifier, value, put)
     * table.checkAndDelete(row, family, qualifier, value, delete)
     * @throws IOException
     */</span>
    @Test public void atomicOP<span class="params">()</span> throws IOException{
        byte[] row = Bytes.toBytes<span class="params">(<span class="string">"row-12"</span>)</span>;
        byte[] family = Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>;

        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        <span class="comment">//操作成功会返回 true,否则false;  如果是个不存在的qualifier, 把value置为null  check是会成功的</span>
        Put put = new Put<span class="params">(row)</span>;
        put.add<span class="params">(family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"value12"</span>)</span>)</span>;
        <span class="comment">//check 和put是同一个row</span>
        boolean result1 = table.checkAndPut<span class="params">(row, family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>, null, put)</span>;  <span class="comment">//true</span>
        boolean result2 = table.checkAndPut<span class="params">(row, family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>, null, put)</span>;   <span class="comment">//false</span>

        Put put2 = new Put<span class="params">(row)</span>;
        put2.add<span class="params">(family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"value12"</span>)</span>)</span>;
        boolean result3 = table.checkAndPut<span class="params">(row, family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>,
                Bytes.toBytes<span class="params">(<span class="string">"value12"</span>)</span>, put2)</span>;  <span class="comment">//true</span>

        Put put3 = new Put<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-13"</span>)</span>)</span>;
        put3.add<span class="params">(family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"value13"</span>)</span>)</span>;
        boolean result4 = table.checkAndPut<span class="params">(row, family, Bytes.toBytes<span class="params">(<span class="string">"namex2"</span>)</span>,
                Bytes.toBytes<span class="params">(<span class="string">"value12"</span>)</span>, put3)</span>;  <span class="comment">//org.apache.hadoop.hbase.DoNotRetryIOException</span>
        <span class="comment">//注意：check 和put的一定要是同一行 否则会报错</span>

<span class="comment">//      table.checkAndDelete类似</span>
    }

    <span class="comment">/**
     * 上面的一些操作有些方法可能涉及到Row Locks 但并没有说明   这里详细介绍下
     *
     * 一些会使数据发生变化的操作  比如like put(), delete(), checkAndPut()等等 , 操作都是以一个row为单位的,
     * 使用row lock 可以保证  一次性只能有一个客户端修改一个row
     * 虽然 实践中  客户端应用程序 并没有明确的使用lock, 但服务端会在适当的时机保护每一个独立的操作
     *
     * 如果可能应当尽量避免使用lock, 就像RSBMS一样会有死锁问题
     * @throws IOException
     */</span>
    @Test public void rowLocksTest<span class="params">()</span> throws IOException{
        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        byte[] row = Bytes.toBytes<span class="params">(<span class="string">"row-8"</span>)</span>;
        RowLock lock = table.lockRow<span class="params">(row)</span>;
        <span class="comment">//.....相关操作</span>
        table.unlockRow<span class="params">(lock)</span>;
        <span class="comment">//锁有效时间 默认时间是1分钟</span>
    }

    @SuppressWarnings<span class="params">(<span class="string">"deprecation"</span>)</span>
    @Test public void getTest<span class="params">()</span>{
        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        Get get = new Get<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-10"</span>)</span>)</span>;
        <span class="comment">//默认 get 只会取得最新的记录, 使用下面的方法可以获取其他的版本</span>
        <span class="comment">//有两个方法 一个带参数的可以指定版本数量, 可能会抛出异常;另外一个没有</span>
        <span class="comment">// 参数, 默认Integer.MAX_VALUE, 不会抛出异常</span>
        get.setMaxVersions<span class="params">()</span>;
    <span class="comment">//  get.setFilter(filter); get 一般数据比较少比较少使用filter, 在Scan的时候会详细介绍Filter</span>
        <span class="comment">//通过get.addColumn提供了各种重载方法, 可以过滤只获取哪些ColumnFamily</span>
        <span class="comment">// 和Column,get实现这种过滤只能使用这种方法, 接下来的Scan还可以使用Filter来实现</span>
        get.addColumn<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>,Bytes.toBytes<span class="params">(<span class="string">"email"</span>)</span>)</span>;

        try {
            Result result = table.get<span class="params">(get)</span>;
            <span class="comment">//这是一个简单的 获取返回结果的方法, 还有其他的通过遍历Map的方式</span>
            List&lt;KeyValue&gt; values = result.list<span class="params">()</span>;
            <span class="comment">//由于KeyValue靠近底层, 对于一些一些Offset,Length结尾的方法 可以忽略,</span>
            <span class="comment">// 比较感兴趣的可以关注下Hbase的底层存储</span>
            <span class="keyword">for</span> <span class="params">(KeyValue keyValue : values)</span> {
                StringBuilder sb = new StringBuilder<span class="params">(Bytes.toString<span class="params">(keyValue.getFamily<span class="params">()</span>)</span>)</span>;
                sb.append<span class="params">(<span class="string">":"</span>)</span>.append<span class="params">(Bytes.toString<span class="params">(keyValue.getQualifier<span class="params">()</span>)</span>)</span>.append<span class="params">(<span class="string">"--:"</span>)</span>;
                sb.append<span class="params">(Bytes.toString<span class="params">(keyValue.getValue<span class="params">()</span>)</span>)</span>.append<span class="params">(<span class="string">"  "</span>)</span>.append<span class="params">(
                        new Date<span class="params">(keyValue.getTimestamp<span class="params">()</span>)</span>.toLocaleString<span class="params">()</span>)</span>;
                System.out.println<span class="params">(sb.toString<span class="params">()</span>)</span>;
            }

            <span class="comment">//这是另外一种获取返回结果的方式, 这种在Scan的返回多个Result的时候</span>
            <span class="comment">// 相对实用, 一个rowkey的都在一起, 一个ColumnFamily的也聚合在一起</span>
            NavigableMap&lt;byte[], NavigableMap&lt;byte[], NavigableMap&lt;Long, byte[]&gt;&gt;&gt; nMap = result.getMap<span class="params">()</span>;
            <span class="keyword">for</span> <span class="params">(Map.Entry&lt;byte[], NavigableMap&lt;byte[], NavigableMap&lt;Long, byte[]&gt;&gt;&gt; entry:nMap.entrySet<span class="params">()</span> )</span> {
                <span class="comment">//entry.getKey()为family key</span>
                String family = Bytes.toString<span class="params">(entry.getKey<span class="params">()</span>)</span>;
                System.out.print<span class="params">(family+<span class="string">":"</span>)</span>;
                <span class="keyword">for</span> <span class="params">(Map.Entry&lt;byte[], NavigableMap&lt;Long, byte[]&gt;&gt; entry2 : entry.getValue<span class="params">()</span>.entrySet<span class="params">()</span> )</span> {
                    <span class="comment">// entry2.getKey()为qualifier  当然qualifier有可能为空  这个不是问题  但为null的只能有一个</span>
                    String qualifier = Bytes.toString<span class="params">(entry2.getKey<span class="params">()</span>)</span>;
                    System.out.print<span class="params">(qualifier+<span class="string">"--:"</span>)</span>;
                    <span class="keyword">for</span> <span class="params">(Map.Entry&lt;Long, byte[]&gt; entry3:entry2.getValue<span class="params">()</span>.entrySet<span class="params">()</span> )</span> {
                        <span class="comment">//entry3.getKey()为 timestamp  entry3.getValue()为 value</span>
                        System.out.print<span class="params">(Bytes.toString<span class="params">(entry3.getValue<span class="params">()</span>)</span>+<span class="string">" "</span>
                                +new Date<span class="params">(entry3.getKey<span class="params">()</span>)</span>.toLocaleString<span class="params">()</span>)</span>;
                    }
                }
            }
            System.out.println<span class="params">(<span class="string">"------------------"</span>)</span>;
            <span class="comment">//Get的批处理类似于 SQL中的in操作,但操作起来也相当的简单, 和上面</span>
            <span class="comment">// 的Put Delete非常类似,也可以混合使用</span>
            List&lt;Row&gt; rows = new ArrayList&lt;Row&gt;<span class="params">()</span>;
            rows.add<span class="params">(new Get<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-10"</span>)</span>)</span>)</span>;
            rows.add<span class="params">(new Get<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-11"</span>)</span>)</span>)</span>;
            rows.add<span class="params">(new Put<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-1222221"</span>)</span>)</span>)</span>;
            try {
                Object[] objs = table.batch<span class="params">(rows)</span>;
                <span class="keyword">for</span> <span class="params">(Object obj : objs)</span> {
                    printKeyValue<span class="params">(<span class="params">(Result)</span>obj)</span>;
                }
            } catch <span class="params">(InterruptedException e)</span> {
                e.printStackTrace<span class="params">()</span>;
            }

        } catch <span class="params">(IOException e)</span> {
            e.printStackTrace<span class="params">()</span>;
        }
        <span class="comment">/**
         * Get获取单个 或随机的几个row 使用起来非常方便, 对于访问多个连续的row
         * 使用下面将要介绍的Scan操作,通常情况下, 完成一个业务 需要多个操作, 而
         * ORM无法将一个业务所有的操作SQL封装在一起, 除非直接使用JDBC
         * Hbase的这种 Put Get Delete 是不是很棒 , 对了没有Update, update的就
         * 是新增一条, 由于有版本, 旧的不会被立即淘汰掉
         */</span>
    }

    public void printKeyValue<span class="params">(Result result)</span>{
        List&lt;KeyValue&gt; values = result.list<span class="params">()</span>;
        <span class="comment">//由于KeyValue靠近底层, 对于一些一些Offset,Length结尾的方法 可以忽略,</span>
        <span class="comment">// 比较感兴趣的可以关注下Hbase的底层存储</span>
        <span class="keyword">for</span> <span class="params">(KeyValue keyValue : values)</span> {
            StringBuilder sb = new StringBuilder<span class="params">(Bytes.toString<span class="params">(keyValue.getFamily<span class="params">()</span>)</span>)</span>;
            sb.append<span class="params">(<span class="string">":"</span>)</span>.append<span class="params">(Bytes.toString<span class="params">(keyValue.getQualifier<span class="params">()</span>)</span>)</span>.append<span class="params">(<span class="string">"--:"</span>)</span>;
            sb.append<span class="params">(Bytes.toString<span class="params">(keyValue.getValue<span class="params">()</span>)</span>)</span>.append<span class="params">(<span class="string">"  "</span>)</span>.append<span class="params">(
                    new Date<span class="params">(keyValue.getTimestamp<span class="params">()</span>)</span>.toLocaleString<span class="params">()</span>)</span>;
            System.out.println<span class="params">(sb.toString<span class="params">()</span>)</span>;
        }
    }

    <span class="comment">/**
     * 对于连续记录的顺序访问  就是类似于 最常见的Select操作
     * 实际上Scan 非常类似于Hibernate 的DetachedCriteria, 而scan 使用的Filter就相当于Criteria的Expression或Restrictions
     * 可以实现离线封装查询条件   这个是相当的给力啊
     */</span>
    @Test public void ScanTest<span class="params">()</span>{
        ResultScanner resultScanner = null;
        try {
            <span class="comment">/**
             * 如Scan的名字, Scan是在一定的范围内startkey(StartRow)和endkey(StopRow)
             * 之间 顺序的扫描, 配合Filter 可以跳过不满足条件的记录  返回需要的结果
             * 当然startkey和endkey只是标识一个范围, 它们对应的rowkey可能并不存在,
             * 但如果存在(startkey) 扫描的范围是[startkey,endkey),否则就是(startkey,endkey)
             * 可以看到 Scan 有一个包裹Get的构造, 可以利用该get的rowkey作为startkey
             */</span>
            Scan scan  = new Scan<span class="params">()</span>;

            <span class="comment">/**
             * ResultScanner 就是table scanner返回的结果集, 类似于游标 可以迭代获取结果,
             * batch 就是每次迭代从服务器获取的记录数, 设置太小 会频繁到服务器取数据,
             * 太大 会对客户端造成比较大的压力,  具体根据需要使用 , 正常使用可以不必管
             * 它, 大批量读取可以考虑用它改善性能
             * 这里要注意了： 这个记录数是qualifier不是row, 如果一个row有17个qualifier,
             * setBatch(5),一个row就会分散到4个Result中, 分别持有5,5,5,2个qualifier
             * （默认一个row的所有qualifier会在一个Result中）
             *
             * ColumnPaginationFilter 对于一个Row会在一个Result 但是只返回前面一部分
             *
             * 如果使用FirstKeyOnlyFilter等 不是扫描Row全部的Filter 会有冲突 会有异常抛出 */</span>
            scan.setBatch<span class="params">(<span class="number">10</span>)</span>;
            <span class="comment">/**发给scanners的缓存的Row的数量, 如果没有设置会使用 HTable#getScannerCaching()的值
             * 一般 越大 Scan速度越快, 但消耗的内存也越大*/</span>
            scan.setCaching<span class="params">(<span class="number">10</span>)</span>;
            <span class="comment">//简而言之就是  batch 是qualifier column级别的   caching是row级别的</span>

            <span class="comment">//RegionServer是否应当缓存 当前客户端访问过的数据块    如果是随机的get 这个最好为false</span>
            scan.setCacheBlocks<span class="params">(<span class="literal">true</span>)</span>;

            <span class="comment">/** Scan 最复杂, 也最有用的就是Filter, 特别是FilterList对Filter进行的组合
             * 这里只先介绍Scan的其他参数 ;对于Filter,后面会单独介绍*/</span>

            <span class="comment">//startrow和stoprow 可以改变</span>
            scan.setStartRow<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-12"</span>)</span>)</span>;
            scan.setStopRow<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-1110"</span>)</span>)</span>;
            scan.setMaxVersions<span class="params">(<span class="number">3</span>)</span>;<span class="comment">//同Get</span>
            <span class="comment">/** 可以指定一个时间范围, 扫描指定时间或时间范围的的记录,  */</span>
            scan.setTimeRange<span class="params">(System.currentTimeMillis<span class="params">()</span>-<span class="number">1000000</span>, System.currentTimeMillis<span class="params">()</span>)</span>;
            <span class="comment">/**
             * 也可以指定timestamp 查询
             */</span>
            scan.setTimeStamp<span class="params">(System.currentTimeMillis<span class="params">()</span>)</span>;

            <span class="comment">/**可以使用Get中类似的方法 来限制获取的ColumnFamily Column*/</span>
            scan.addColumn<span class="params">(Bytes.toBytes<span class="params">(<span class="string">""</span>)</span>,Bytes.toBytes<span class="params">(<span class="string">""</span>)</span>)</span>;

            <span class="comment">//Scan中使用最多的还是Filter</span>
            HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
            <span class="comment">//看下面</span>
            table.setScannerCaching<span class="params">(<span class="number">1000</span>)</span>;
            resultScanner = table.getScanner<span class="params">(scan)</span>;
            <span class="comment">//这是foreach格式    是调用resultScanner.next()的</span>
            <span class="comment">//默认情况下  每次调用next() 都要RPC一下服务器   每个row一次, 即时resultScanner(int nbRows)</span>
            <span class="comment">//table.setScannerCaching() 默认是1  可以手工设置  设置后 该table实例的所有scan都有效</span>
            <span class="comment">//也可以每个scan单设置定就是上面有说过的scan.setCaching(1024*10); 这个会覆盖table设置的值</span>
            <span class="keyword">for</span> <span class="params">(Result result : resultScanner)</span> {
                <span class="comment">//这里就不多说了   和Get中一样的解析</span>
            }

        } catch <span class="params">(IOException e)</span> {
            e.printStackTrace<span class="params">()</span>;
        }finally{
            <span class="comment">//这样一定要记住 用完close</span>
            <span class="keyword">if</span><span class="params">(resultScanner!=null)</span>resultScanner.close<span class="params">()</span>;
        }

    }

    <span class="comment">/**
     * 高级的Scan,就是Filter中的FilterList  可以组合各个Filter
     * select cf1.column1,cf2.column2* from table_name where rowkey&gt;10 or value like 'xxx%' limit 10
     * 如果上面的SQL解析出来 and 表示MUST_PASS_ALL, or 表示MUST_PASS_ONE
     * 就是下面这个样(虽然理解可能不同,但下图的代码如下：)
     *  ( (cf1 and column1) or (cf2 and column2*)  ) and (rowkey&gt;10 or value like 'xxx%')
     * setFilter(
     *                                                        -ColumnFamilyFilter  cf1
     *                                     -filterList(ALL)--|
     *                                    |                   -ColumnFilter   column1
     *                  -filterList(ONE)-&gt;|
     *                 |                  |                   -ColumnFamilyFilter cf2
     *                 |                   -filterList(ALL)--|
     *                 |                                      -ColumnPrefixFilter column2
     *filterList(ALL)-&gt;|                -RowFilter 10
     *                 |-filterList(ONE)-&gt;|
     *                 |                   -ValueFilter xx
     *                  -PageFilter 10
     * @author Administrator
     *
     */</span>
    @Test public void scanAdvance<span class="params">()</span>{
        Scan scan  = new Scan<span class="params">()</span>;
        List&lt;Filter&gt; rootList = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
            List&lt;Filter&gt; selectList = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
                List&lt;Filter&gt; select_1 = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
                    select_1.add<span class="params">(new FamilyFilter<span class="params">(CompareFilter.CompareOp.EQUAL,
                            new BinaryComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"cf1"</span>)</span>)</span>)</span>)</span>;
                    select_1.add<span class="params">(new QualifierFilter<span class="params">(CompareFilter.CompareOp.EQUAL,
                            new BinaryComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"column1"</span>)</span>)</span>)</span>)</span>;
                List&lt;Filter&gt; select_2 = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
                    select_2.add<span class="params">(new FamilyFilter<span class="params">(CompareFilter.CompareOp.EQUAL,
                            new BinaryComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"cf2"</span>)</span>)</span>)</span>)</span>;
                    select_2.add<span class="params">(new QualifierFilter<span class="params">(CompareFilter.CompareOp.EQUAL,
                            new BinaryPrefixComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"column"</span>)</span>)</span>)</span>)</span>;
            selectList.add<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ALL, select_1)</span>)</span>;
            selectList.add<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ALL, select_2)</span>)</span>;
        rootList.add<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ONE,selectList)</span>)</span>;

            List&lt;Filter&gt; whereList = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
                whereList.add<span class="params">(new RowFilter<span class="params">(CompareFilter.CompareOp.GREATER,
                        new BinaryComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="number">10</span>)</span>)</span>)</span>)</span>;
                whereList.add<span class="params">(new RowFilter<span class="params">(CompareFilter.CompareOp.EQUAL,
                        new BinaryPrefixComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"xxx"</span>)</span>)</span>)</span>)</span>;
        rootList.add<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ONE,whereList)</span>)</span>;
        scan.setFilter<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ALL, rootList)</span>)</span>;
        <span class="comment">//这样的嵌套 写起来着实很烦, 可以自己封装成程序</span>
    }

    <span class="comment">/**
     * 一个不得不说的操作  分页操作, 
     * RDBMS 比如mysql :select * from table_name where sss=sss limit 1 10;
     * oracle 利用rownum也可以迂回实现,
     * Hbase这方面支持的不是太好, 也可以支持翻页
     */</span>
    @Test public void pageTest<span class="params">()</span>{
        <span class="comment">//与传统的分页的不同  start 是个起始的row  而不是一个数字 ,   下一页 的时候</span>
        <span class="comment">// 需要将上一页的最后一条记录作为分页条件传回来</span>
        <span class="comment">//这个start要是byte[],页面上只能暂时保存字符串  怎么办呢？？</span>
        <span class="comment">//Bytes.toStringBinary(byte[])与Bytes.toBytesBinary(String) 可以完美的实现字符串和byte[]的相互转换</span>
        <span class="comment">// Bytes.toStringBinary(Bytes.toBytesBinary("abc")) equals "abc" 是true</span>
        byte[] start = Bytes.toBytes<span class="params">(<span class="string">"row-13"</span>)</span>;
        int limit = <span class="number">10</span>;
        Scan scan = new Scan<span class="params">()</span>;
        scan.setStartRow<span class="params">(start)</span>;

        List&lt;Filter&gt; rootList = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
        rootList.add<span class="params">(new PageFilter<span class="params">(limit)</span>)</span>;
        <span class="comment">////root.add(new Filter()) 添加其他的过滤条件</span>

        scan.setFilter<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ALL, rootList)</span>)</span>;
    }

    <span class="comment">/**除了上面用到的
     * Htable 还有一些其他的有用方法
     * @throws IOException
     */</span>
    @SuppressWarnings<span class="params">(<span class="string">"unused"</span>)</span>
    @Test public void htableOthers<span class="params">()</span> throws IOException{
        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        byte [] row = Bytes.toBytes<span class="params">(<span class="string">"row-13"</span>)</span>;
        <span class="comment">//获取指定row的 数据所在的Region的信息 ：名字, 编码后名字(Hadoop 中的</span>
        <span class="comment">// 路径名), startKey endkey等---&gt;hri  ；还有该Region所在的主机的地址信息---&gt;addr</span>
        HRegionLocation hrl = table.getRegionLocation<span class="params">(row)</span>;
        HRegionInfo hri= hrl.getRegionInfo<span class="params">()</span>;
        HServerAddress addr = hrl.getServerAddress<span class="params">()</span>;

        <span class="comment">//获取所有Region的信息</span>
        Map&lt;HRegionInfo,HServerAddress&gt; regions = table.getRegionsInfo<span class="params">()</span>;

        <span class="comment">//获取该表所在的所有Region的  startKey 和 endKey</span>
        Pair&lt;byte[][], byte[][]&gt; startendKeys = table.getStartEndKeys<span class="params">()</span>;
        <span class="comment">//下面的是通过上面的实现的</span>
        table.getStartKeys<span class="params">()</span>;
        table.getEndKeys<span class="params">()</span>;

        <span class="comment">//table.getRowOrBefore(row, family) 这个一般用不到  0.92时候 就要被废弃了</span>
    }

    <span class="comment">/**
     * 操作完成后, 清理下资源还是很有必要的,
     * 在系统的ServletContextListener
     */</span>
    @AfterClass
    public static void after<span class="params">()</span>{
        try {
            <span class="keyword">if</span><span class="params">(conf!=null)</span> HConnectionManager.deleteConnection<span class="params">(conf, <span class="literal">false</span>)</span>;
            <span class="keyword">if</span><span class="params">(pool!=null)</span>pool.close<span class="params">()</span>;
        } catch <span class="params">(IOException e)</span> {
            e.printStackTrace<span class="params">()</span>;
        }
    }
}
        <span class="comment">// 路径名), startKey endkey等---&gt;hri  ；还有该Region所在的主机的地址信息---&gt;addr</span>
        HRegionLocation hrl = table.getRegionLocation<span class="params">(row)</span>;
        HRegionInfo hri= hrl.getRegionInfo<span class="params">()</span>;
        HServerAddress addr = hrl.getServerAddress<span class="params">()</span>;

        <span class="comment">//获取所有Region的信息</span>
        Map&lt;HRegionInfo,HServerAddress&gt; regions = table.getRegionsInfo<span class="params">()</span>;

        <span class="comment">//获取该表所在的所有Region的  startKey 和 endKey</span>
        Pair&lt;byte[][], byte[][]&gt; starten
</code></pre>
      
      


    </div>
    
    <footer class="article-footer">
      
        <a data-url="http://liuziquan.github.io/2015/09/11/HBase入门实例/" data-id="cief7ww300000d4mkynzgveyl" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HBase/">HBase</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HBase简单Java代码示例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/11/HBase简单Java代码示例/" class="article-date">
  <time datetime="2015-09-10T16:00:00.000Z" itemprop="datePublished">2015-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/HBase/">HBase</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/11/HBase简单Java代码示例/">HBase简单Java代码示例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      

<!-- Table of Contents -->


        <p>这里我们用一个学生成绩表作为例子,对HBase的基本操作和基本概念进行讲解:<br>下面是学生的成绩表:</p>
<table>
<thead>
<tr>
<th>name</th>
<th>grade</th>
<th>course:math</th>
<th>course:art</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tom</td>
<td>1</td>
<td>87</td>
<td>97</td>
</tr>
<tr>
<td>Jerry</td>
<td>2</td>
<td>100</td>
<td>80</td>
</tr>
</tbody>
</table>
<p>这里grade对于表来说是一个列,course对于表来说是一个列族,这个列族由两个列组成:math和art,<br>当然我们可以根据我们的需要在course中建立更多的列族,如computer,physics等相应的列添加入course列族.<br>有了上面的想法和需求,我们就可以在HBase中建立相应的数据表啦!</p>
<ol>
<li><p>建立一个表格 scores 具有两个列族grade 和courese</p>
<pre><code><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">002</span>:<span class="number">0</span>&gt; create <span class="string">'scores'</span>, <span class="string">'grade'</span>, <span class="string">'course'</span>
<span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">4.1610</span> seconds
</code></pre></li>
<li><p>查看当先HBase中具有哪些表</p>
<pre><code><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">003</span>:<span class="number">0</span>&gt; list
scores
<span class="number">1</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.0210</span> seconds
</code></pre></li>
<li><p>查看表的构造</p>
<pre><code>hbase(main):<span class="number">004</span>:<span class="number">0</span>&gt; describe <span class="string">'scores'</span>
{NAME =&gt; <span class="string">'scores'</span>, IS_ROOT =&gt; <span class="string">'false'</span>, IS_META =&gt; <span class="string">'false'</span>, FAMILIES =&gt; [{NAME =&gt; <span class="string">'course'</span>, BLOOMFILTER =&gt; <span class="string">'false'</span>, IN_MEMORY =&gt; <span class="string">'false'</span>, LENGTH =&gt; <span class="string">'2147483647'</span>, BLOCKCACHE =&gt; <span class="string">'false'</span>, VERSIONS =&gt; <span class="string">'3'</span>, TTL =&gt; <span class="string">'-1'</span>, COMPRESSION =&gt; <span class="string">'NONE'</span>}, {NAME =&gt; <span class="string">'grade'</span>, BLOOMFILTER =&gt; <span class="string">'false'</span>, IN_MEMORY =&gt; <span class="string">'false'</span>, LENGTH =&gt; <span class="string">'2147483647'</span>, BLOCKCACHE =&gt; <span class="string">'false'</span>, VERSIONS =&gt; <span class="string">'3'</span>, TTL =&gt; <span class="string">'-1'</span>, COMPRESSION =&gt; <span class="string">'NONE'</span>}]}
<span class="number">1</span> row(s) <span class="keyword">in</span> <span class="number">0.0130</span> seconds
</code></pre></li>
<li><p>加入一行数据,行名称为 Tom 列族grad的列名为”” 值位1</p>
<pre><code><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">005</span>:<span class="number">0</span>&gt; put <span class="string">'scores'</span>, <span class="string">'Tom'</span>, <span class="string">'grade:'</span>, <span class="string">'1'</span>
<span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.0070</span> seconds
</code></pre></li>
<li><p>给Tom这一行的数据的列族添加一列</p>
<pre><code><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">006</span>:<span class="number">0</span>&gt; put <span class="string">'scores'</span>, <span class="string">'Tom'</span>, <span class="string">'course:math'</span>, <span class="string">'87'</span>
<span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.0040</span> seconds
</code></pre></li>
<li><p>给Tom这一行的数据的列族添加一列</p>
<pre><code><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">007</span>:<span class="number">0</span>&gt; put <span class="string">'scores'</span>, <span class="string">'Tom'</span>, <span class="string">'course:art'</span>, <span class="string">'97'</span>
<span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.0030</span> seconds
</code></pre></li>
<li><p>加入一行数据,行名称为 Jerry 列族grad的列名为”” 值位2</p>
<pre><code><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">008</span>:<span class="number">0</span>&gt; put <span class="string">'scores'</span>, <span class="string">'Jerry'</span>, <span class="string">'grade:'</span>, <span class="string">'2'</span>
<span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.0040</span> seconds
</code></pre></li>
<li><p>给Jerry这一行的数据的列族添加一列</p>
<pre><code><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">009</span>:<span class="number">0</span>&gt; put <span class="string">'scores'</span>, <span class="string">'Jerry'</span>, <span class="string">'course:math'</span>, <span class="string">'100'</span>
<span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.0030</span> seconds
</code></pre></li>
<li><p>给Jerry这一行的数据的列族添加一列</p>
<pre><code><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">010</span>:<span class="number">0</span>&gt; put <span class="string">'scores'</span>, <span class="string">'Jerry'</span>, <span class="string">'course:art'</span>, <span class="string">'80'</span>
<span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.0050</span> seconds
</code></pre></li>
<li><p>查看scores表中Tom的相关数据</p>
<pre><code>hbase(main):011:<span class="operator">0&gt; <span class="keyword">get</span> <span class="string">'scores'</span>, <span class="string">'Tom'</span>
<span class="keyword">COLUMN</span>                       CELL
course:art                  <span class="keyword">timestamp</span>=<span class="number">1224726394286</span>, <span class="keyword">value</span>=<span class="number">97</span>
course:math                 <span class="keyword">timestamp</span>=<span class="number">1224726377027</span>, <span class="keyword">value</span>=<span class="number">87</span>
grade:                      <span class="keyword">timestamp</span>=<span class="number">1224726360727</span>, <span class="keyword">value</span>=<span class="number">1</span>
<span class="number">3</span> <span class="keyword">row</span>(s) <span class="keyword">in</span> <span class="number">0.0070</span> seconds</span>
</code></pre></li>
<li><p>查看scores表中所有数据</p>
<pre><code>hbase(main):012:0&gt; scan 'scores'
ROW                          COLUMN+CELL
Tom                         column=course:art, timestamp=1224726394286, value=97
Tom                         column=course:math, timestamp=1224726377027, value=87
Tom                         column=grade:, timestamp=1224726360727, value=1
Jerry                        column=course:art, timestamp=1224726424967, value=80
Jerry                        column=course:math, timestamp=1224726416145, value=100
Jerry                        column=grade:, timestamp=1224726404965, value=2
6 row(s) in 0.0410 seconds
</code></pre></li>
<li><p>查看scores表中所有数据courses列族的所有数据</p>
<pre><code>hbase(main):013:<span class="operator">0&gt; <span class="keyword">scan</span> <span class="string">'scores'</span>,{<span class="keyword">COLUMN</span>=&gt;[<span class="string">'course'</span>]}        
<span class="keyword">ROW</span>                                      <span class="keyword">COLUMN</span>+CELL                                                                                                        
 Jerry                                   <span class="keyword">column</span>=course:art, <span class="keyword">timestamp</span>=<span class="number">1441953970540</span>, <span class="keyword">value</span>=<span class="number">80</span>                                                               
 Jerry                                   <span class="keyword">column</span>=course:math, <span class="keyword">timestamp</span>=<span class="number">1441953959676</span>, <span class="keyword">value</span>=<span class="number">100</span>                                                             
 Tom                                     <span class="keyword">column</span>=course:art, <span class="keyword">timestamp</span>=<span class="number">1441953935469</span>, <span class="keyword">value</span>=<span class="number">97</span>                                                               
 Tom                                     <span class="keyword">column</span>=course:math, <span class="keyword">timestamp</span>=<span class="number">1441953923125</span>, <span class="keyword">value</span>=<span class="number">87</span>                                                              
<span class="number">2</span> <span class="keyword">row</span>(s) <span class="keyword">in</span> <span class="number">0.0640</span> seconds</span>
</code></pre></li>
</ol>
<p>上面就是HBase的基本shell操作的一个例子,可以看出,hbase的shell还是比较简单易用的,<br>从中也可以看出HBase shell缺少很多传统sql中的一些类似于like等相关操作,<br>当然,HBase作为BigTable的一个开源实现,而BigTable是作为 google业务的支持模型,<br>很多sql语句中的一些东西可能还真的不需要.<br>当然,通过程序我们也可以对HBase进行相关的操作.下面的程序就完成了上面shell操作的内容:</p>
<pre><code><span class="built_in">import</span> java.io.IOException;
<span class="built_in">import</span> java.io.ByteArrayOutputStream;
<span class="built_in">import</span> java.io.DataOutputStream;
<span class="built_in">import</span> java.io.ByteArrayInputStream;
<span class="built_in">import</span> java.io.DataInputStream;
<span class="built_in">import</span> java.util.Map;
<span class="built_in">import</span> org.apache.hadoop.io.Writable;
<span class="built_in">import</span> org.apache.hadoop.io.IntWritable;
<span class="built_in">import</span> org.apache.hadoop.hbase.HBaseConfiguration;
<span class="built_in">import</span> org.apache.hadoop.hbase.HTableDescriptor;
<span class="built_in">import</span> org.apache.hadoop.hbase.HColumnDescriptor;
<span class="built_in">import</span> org.apache.hadoop.hbase.client.HBaseAdmin;
<span class="built_in">import</span> org.apache.hadoop.hbase.client.HTable;
<span class="built_in">import</span> org.apache.hadoop.hbase.io.BatchUpdate;
<span class="built_in">import</span> org.apache.hadoop.hbase.io.RowResult;
<span class="built_in">import</span> org.apache.hadoop.hbase.io.Cell;
<span class="built_in">import</span> org.apache.hadoop.hbase.util.Writables;
public class HBaseBasic {
    public static void main<span class="params">(String[] args)</span> throws Exception {
        HBaseConfiguration config = new HBaseConfiguration<span class="params">()</span>;
        HBaseAdmin admin = new HBaseAdmin<span class="params">(config)</span>;
        <span class="keyword">if</span> <span class="params">(admin.tableExists<span class="params">(<span class="string">"scores"</span>)</span>)</span> {
            System.out.println<span class="params">(<span class="string">"drop table"</span>)</span>;
            admin.disableTable<span class="params">(<span class="string">"scores"</span>)</span>;
            admin.deleteTable<span class="params">(<span class="string">"scores"</span>)</span>;
        }

        System.out.println<span class="params">(<span class="string">"create table"</span>)</span>;
        HTableDescriptor tableDescripter = new HTableDescriptor<span class="params">(<span class="string">"scores"</span>.getBytes<span class="params">()</span>)</span>;
        tableDescripter.addFamily<span class="params">(new HColumnDescriptor<span class="params">(<span class="string">"grade:"</span>)</span>)</span>;
        tableDescripter.addFamily<span class="params">(new HColumnDescriptor<span class="params">(<span class="string">"course:"</span>)</span>)</span>;
        admin.createTable<span class="params">(tableDescripter)</span>;
        HTable table = new HTable<span class="params">(config, <span class="string">"scores"</span>)</span>;

        System.out.println<span class="params">(<span class="string">"add Tom's data"</span>)</span>;
        BatchUpdate tomUpdate = new BatchUpdate<span class="params">(<span class="string">"Tom"</span>)</span>;
        tomUpdate.put<span class="params">(<span class="string">"grade:"</span>, Writables.getBytes<span class="params">(new IntWritable<span class="params">(<span class="number">1</span>)</span>)</span>)</span>;
        tomUpdate.put<span class="params">(<span class="string">"course:math"</span>, Writables.getBytes<span class="params">(new IntWritable<span class="params">(<span class="number">87</span>)</span>)</span>)</span>;
        tomUpdate.put<span class="params">(<span class="string">"course:art"</span>, Writables.getBytes<span class="params">(new IntWritable<span class="params">(<span class="number">97</span>)</span>)</span>)</span>;
        table.commit<span class="params">(tomUpdate)</span>;

        System.out.println<span class="params">(<span class="string">"add Jerry's data"</span>)</span>;
        BatchUpdate jerryUpdate = new BatchUpdate<span class="params">(<span class="string">"Jerry"</span>)</span>;
        jerryUpdate.put<span class="params">(<span class="string">"grade:"</span>, Writables.getBytes<span class="params">(new IntWritable<span class="params">(<span class="number">2</span>)</span>)</span>)</span>;
        jerryUpdate.put<span class="params">(<span class="string">"course:math"</span>, Writables.getBytes<span class="params">(new IntWritable<span class="params">(<span class="number">100</span>)</span>)</span>)</span>;
        jerryUpdate.put<span class="params">(<span class="string">"course:art"</span>, Writables.getBytes<span class="params">(new IntWritable<span class="params">(<span class="number">80</span>)</span>)</span>)</span>;
        table.commit<span class="params">(jerryUpdate)</span>;
        <span class="keyword">for</span> <span class="params">(RowResult row : table.getScanner<span class="params">(new String[] { <span class="string">"course:"</span> })</span>)</span> {
            System.out.format<span class="params">(<span class="string">"ROW\t%s\n"</span>, new String<span class="params">(row.getRow<span class="params">()</span>)</span>)</span>;
            <span class="keyword">for</span> <span class="params">(Map.Entry&lt;byte[], Cell&gt; entry : row.entrySet<span class="params">()</span>)</span> {
                String column = new String<span class="params">(entry.getKey<span class="params">()</span>)</span>;
                Cell cell = entry.getValue<span class="params">()</span>;
                IntWritable value = new IntWritable<span class="params">()</span>;
                Writables.copyWritable<span class="params">(cell.getValue<span class="params">()</span>, value)</span>;
                System.out.format<span class="params">(<span class="string">" COLUMN\t%s\t%d\n"</span>, column, value.get<span class="params">()</span>)</span>;
            }
        }
    }
}
</code></pre><p>输出如下:</p>
<pre><code><span class="operator"><span class="keyword">drop</span> <span class="keyword">table</span>
<span class="number">09</span>/<span class="number">07</span>/<span class="number">11</span> <span class="number">08</span>:<span class="number">51</span>:<span class="number">59</span> INFO <span class="keyword">client</span>.HBaseAdmin: Disabled scores
<span class="number">09</span>/<span class="number">07</span>/<span class="number">11</span> <span class="number">08</span>:<span class="number">51</span>:<span class="number">59</span> INFO <span class="keyword">client</span>.HBaseAdmin: Deleted scores
<span class="keyword">create</span> <span class="keyword">table</span>
<span class="keyword">add</span> Tom<span class="string">'s data
add Jerry'</span>s <span class="keyword">data</span>
<span class="keyword">ROW</span>     Tom
  <span class="keyword">COLUMN</span>        course:art      <span class="number">97</span>
  <span class="keyword">COLUMN</span>        course:math     <span class="number">87</span>
<span class="keyword">ROW</span>     Jerry
  <span class="keyword">COLUMN</span>        course:art      <span class="number">80</span>
  <span class="keyword">COLUMN</span>        course:math     <span class="number">100</span></span>
</code></pre>
      
      


    </div>
    
    <footer class="article-footer">
      
        <a data-url="http://liuziquan.github.io/2015/09/11/HBase简单Java代码示例/" data-id="ciefazop400006kmk4v39lbe8" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HBase/">HBase</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HBase应用之Table设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/11/HBase应用之Table设计/" class="article-date">
  <time datetime="2015-09-10T16:00:00.000Z" itemprop="datePublished">2015-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/HBase/">HBase</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/11/HBase应用之Table设计/">HBase应用之Table设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      

<!-- Table of Contents -->


        <h3 id="HBase基本类型定义">HBase基本类型定义</h3><ul>
<li>Table：表 </li>
<li>RowKey：行健，主键</li>
<li>Column Family：列族，包含一个或者多个相关列</li>
<li>Column：属于某一个columnfamily，familyName:columnName，每条记录可动态添加</li>
<li>timestamp：每次操作对应的时间戳，支持用户自定义，默认为当前时间的毫秒值</li>
<li>value：值，和timestamp一起支持多version的概念</li>
</ul>
<p>通过HBase Shell可以拿到一条数据，如下：</p>
<pre><code>hbase(main):029:<span class="operator">0&gt; <span class="keyword">scan</span> <span class="string">'scores'</span>,{<span class="keyword">LIMIT</span>=&gt;<span class="number">1</span>}
<span class="keyword">ROW</span>                                      <span class="keyword">COLUMN</span>+CELL                                                                                                        
 Jerry                                   <span class="keyword">column</span>=course:art, <span class="keyword">timestamp</span>=<span class="number">1441953970540</span>, <span class="keyword">value</span>=<span class="number">80</span>                                                               
 Jerry                                   <span class="keyword">column</span>=course:math, <span class="keyword">timestamp</span>=<span class="number">1441953959676</span>, <span class="keyword">value</span>=<span class="number">100</span>                                                             
 Jerry                                   <span class="keyword">column</span>=grade:, <span class="keyword">timestamp</span>=<span class="number">1441953949725</span>, <span class="keyword">value</span>=<span class="number">2</span>                                                                    
<span class="number">1</span> <span class="keyword">row</span>(s) <span class="keyword">in</span> <span class="number">0.0350</span> seconds</span>
</code></pre><p>对应内容：</p>
<pre><code><span class="setting">Jerry =<span class="value">》 RowKey</span></span>
<span class="setting">course =<span class="value">》 Column Family</span></span>
<span class="setting">column =<span class="value">》 art</span></span>
<span class="setting">timestamp =<span class="value">&gt; <span class="number">1441953970540</span></span></span>
<span class="setting">80  =<span class="value">&gt; value</span></span>
</code></pre><h3 id="HBase存储结构">HBase存储结构</h3><ol>
<li>HBase以表（HTable）的形式存储数据</li>
<li>HTable包括很多行，每行通过RowKey唯一标记，行按照RowKey的字典序排列，表在行的方向上分割为多个HRegion</li>
<li>每行包括一个RowKey和多个Column Family，数据按照Column Family进行物理切割，即不同Column Family的数据放在不同的Store中，一个Column Family放在一个Strore中</li>
<li>HRegion由多个Store组成。一个Store由物理上存在的一个MemStrore（内存中）和多个StoreFile（HFile）中</li>
</ol>
<h3 id="设计">设计</h3><p>从应用角度，有两点比较重要：</p>
<ol>
<li>HBase中RowKey是按照字典序排列的</li>
<li>不同Column Family的数据，在物理上是分开的</li>
</ol>
<p>在做table设计的时候，主要围绕上述两点做文章。<br>RowKey的设计需要根据请求数据特点：</p>
<ol>
<li>单个查询，需要尽量缩小Key的长度</li>
<li>范围查询，根据RowKey按字典序排列的特点，针对查询需求设计rowkey，保证范围查询的rowkey在物理上存放在一起</li>
</ol>
<p><strong>Column Family的设计需遵循：尽量避免一次请求需要拿到的Column分布在不同的Column Family中</strong></p>
<h3 id="实例">实例</h3><p>对于基于RowKey的范围查询设计，我们来看一个实例：</p>
<ol>
<li>给出userid，返回这个userid最近插入的N条数据 </li>
<li>给出userid，及一个时间区间，返回这个时间区间的N条数据</li>
</ol>
<p>针对需求，Key设计如下：</p>
<pre><code>Userid_DataTime_InertTime
Userid：即userid
DataTime：数据所属时间(ms)，定义为：Long<span class="class">.MAX_VALUE</span> - dataTime.<span class="function"><span class="title">getTime</span><span class="params">()</span></span>，由于RowKey字典序排列，可以使最近插入的数据排在前面，支持“最近插入的N条数据”的需求
InsertTime：数据入库时间(ns)，取nanotime（InsertTime的存在是由于在这个应用中，Userid+DataTime不能唯一定位一条数据）
</code></pre><p>Key生成代码如下：</p>
<pre><code><span class="comment">//生成RowKey  </span>
<span class="keyword">private</span> <span class="keyword">String</span> buildPutRowKey(<span class="built_in">int</span> userId, Date addTime) {  
        <span class="keyword">String</span> <span class="variable">key</span> = userId + <span class="string">"_"</span> + getRowKeyTimestamp(addTime) + <span class="string">"_"</span> + System.nanoTime();  
        <span class="keyword">return</span> <span class="variable">key</span>;  
}  

<span class="comment">//构建DataTime  </span>
<span class="keyword">private</span> <span class="keyword">long</span> getRowKeyTimestamp(Date addTime) {  
        <span class="keyword">return</span> Long.MAX_VALUE - addTime.getTime();  
}  
</code></pre>
      
      


    </div>
    
    <footer class="article-footer">
      
        <a data-url="http://liuziquan.github.io/2015/09/11/HBase应用之Table设计/" data-id="ciefdkoxh0000comkotlca4c5" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HBase/">HBase</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">推荐文章</h3>
    <div class="widget">
      <ul>
        
        
          
          <li>
            <a href="http://shijiajie.com/2015/08/29/hexo-theme-landscape-plus-optimize/" target="_blank">1. Hexo官方主题landscape-plus优化</a>
          </li>
        
          
          <li>
            <a href="http://www.cnblogs.com/zhcncn/p/4097881.html" target="_blank">2. Hexo搭建Github静态博客</a>
          </li>
        
          
          <li>
            <a href="http://blog.fens.me/hexo-blog-github/" target="_blank">3. Hexo在github上构建免费的Web应用</a>
          </li>
        
          
          <li>
            <a href="http://blog.lmintlcx.com/post/blog-with-hexo.html" target="_blank">4. 使用Hexo搭建博客</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/DB2/" style="font-size: 15px;">DB2</a> <a href="/tags/HBase/" style="font-size: 20px;">HBase</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/DB2/">DB2</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/HBase/">HBase</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MongoDB/">MongoDB</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">2015年 09月</a><span class="archive-list-count">9</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://www.cnblogs.com/shi0090/" target="_blank">石佳劼的博客园</a>
          </li>
        
          <li>
            <a href="https://github.com/stone0090/" target="_blank">石佳劼的GitHub</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  </script>
  
  <div class="outer">
    <div id="footer-info" class="inner">
      Copyright &copy; 2012 - 2015 <a href="http://liuziquan.github.io/" target="_blank">liuziquan</a>.
    </div>
  </div>
</footer>

  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">文章</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->


<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
                processEscapes: true
                    
}
  
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
                  
}
    
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
            for(i=0; i < all.length; i += 1) {
                            all[i].SourceElement().parentNode.className += ' has-jax';
                                    
            }
                
        });
</script>

<script type="text/javascript" src="http://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<script src="/js/script.js" type="text/javascript"></script>

</div>
</body>
</html>
