
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives | Data change world</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- Set render engine for 360 browser -->
  <meta name="renderer" content="webkit">
  <!-- No Baidu Siteapp-->
  <meta http-equiv="Cache-Control" content="no-siteapp"/>
  <meta name="description" content="Data change world!">
<meta property="og:type" content="website">
<meta property="og:title" content="Data change world">
<meta property="og:url" content="http://liuziquan.github.io/archives/index.html">
<meta property="og:site_name" content="Data change world">
<meta property="og:description" content="Data change world!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Data change world">
<meta name="twitter:description" content="Data change world!">
  
  
    <link rel="icon" href="/img/logo.png">
    <meta name="mobile-web-app-capable" content="yes">
    <!-- Add to homescreen for Chrome on Android -->    
    <link rel="icon" sizes="192x192" href="/img/logo.png">
    <!-- Add to homescreen for Safari on iOS -->
    <link rel="apple-touch-icon-precomposed" href="/img/logo.png">    
    <!-- Tile icon for Win8 (144x144 + tile color) -->
    <meta name="msapplication-TileImage" content="/img/logo.png">
    <meta name="msapplication-TileColor" content="#0e90d2">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Data change world</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Anything can be quantified</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">文章</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <!--
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="liuziquan.github.io">
        </form>
      </div>
      -->
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-浅度解析MongoDB的ObjectID生成规则" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/24/浅度解析MongoDB的ObjectID生成规则/" class="article-date">
  <time datetime="2015-09-23T16:00:00.000Z" itemprop="datePublished">2015-09-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MongoDB/">MongoDB</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/24/浅度解析MongoDB的ObjectID生成规则/">浅度解析MongoDB的ObjectID生成规则</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      

<!-- Table of Contents -->


        <h2 id="ObjectID官方指南">ObjectID官方指南</h2><p>ObjectID是类似与“507f1f77bcf86cd799439011”的24位字符串，占用12字节，生成规则如下：</p>
<pre><code>ObjectId is <span class="operator">a</span> <span class="number">12</span>-<span class="keyword">byte</span> BSON type, constructed <span class="keyword">using</span>:
- <span class="number">4</span>-<span class="keyword">byte</span> <span class="built_in">value</span> representing <span class="operator">the</span> <span class="built_in">seconds</span> since <span class="operator">the</span> Unix epoch,
- <span class="number">3</span>-<span class="keyword">byte</span> machine identifier,
- <span class="number">2</span>-<span class="keyword">byte</span> <span class="built_in">process</span> id, <span class="operator">and</span>
- <span class="number">3</span>-<span class="keyword">byte</span> counter, starting <span class="operator">with</span> <span class="operator">a</span> <span class="built_in">random</span> <span class="built_in">value</span>.
</code></pre><h2 id="自定义生成ObjectID">自定义生成ObjectID</h2><p>参考MongoDB的ObjectID生成规则，可自定义生成轻量级的惟一码MyUUID，只需占用8字节<br>其中MyUUID的生成规则如下：</p>
<pre><code>|<span class="string"> 0 </span>|<span class="string"> 1 </span>|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 4 </span>|<span class="string"> 5 </span>|<span class="string"> 6 </span>|<span class="string"> 7 </span>|
---------------------------------
|<span class="string">     time      </span>|<span class="string">mid</span>|<span class="string">   inc     </span>|
</code></pre><p>第０~３字节存放时间，第４字节存放MachineID，第５~７字节存放自增长ID</p>
<h2 id="MyUUID源码">MyUUID源码</h2><p>在一般PC机上，１秒可生成十万不重复的MyUUID，在服务器上效率肯定更高，应该能够满足一般应用要求</p>
<pre><code>import java.util.Date;

<span class="keyword">class</span> MyUUID
{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> _machineID=<span class="number">0</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> _incID=<span class="number">0</span>;

    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMachineID</span><span class="params">()</span> </span>{
        <span class="comment">//复杂些的可以通过主机主板序列号、IP、硬盘序列号等生成机器码，简单起见默认为１</span>
        _machineID+=<span class="number">1</span>;
        <span class="keyword">return</span> _machineID%<span class="number">127</span>;
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInc</span><span class="params">()</span>
    </span>{
        <span class="comment">//一般使用Memcached统一维护一个全局自增ID，简单起见默认为１</span>
        _incID+=<span class="number">1</span>;
        <span class="keyword">return</span> _incID;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">ObjectID</span><span class="params">()</span> </span>{  
        <span class="keyword">long</span> v_time = (<span class="keyword">int</span>) (System.currentTimeMillis() / <span class="number">1000</span>);
        <span class="keyword">int</span> v_machine = getMachineID();
        <span class="keyword">int</span> v_inc = getInc();

        <span class="keyword">long</span> myUUID=<span class="number">0</span>;
        myUUID=myUUID | v_inc;
        myUUID=myUUID | (v_machine&lt;&lt;<span class="number">24</span>);
        myUUID=myUUID | (v_time&lt;&lt;<span class="number">32</span>);

        <span class="keyword">return</span> myUUID;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseObjectID</span><span class="params">(<span class="keyword">long</span> myUUID)</span> 
    </span>{
        <span class="comment">//反向解析myUUID</span>
        <span class="keyword">int</span> v_inc =(<span class="keyword">int</span>) myUUID &amp; <span class="number">0xFFFFFF</span>;<span class="comment">//取出最右边3字节（即24bit）的值，每个16进制数存储4bit</span>
        <span class="keyword">int</span> v_machine=(<span class="keyword">int</span>) (myUUID &gt;&gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;<span class="comment">//无符号右移24位，然后取最右边1字节的值</span>
        <span class="keyword">long</span> v_time=(myUUID &gt;&gt;&gt;<span class="number">32</span>) &amp; <span class="number">0xFFFFFFFF</span>;<span class="comment">//无符号右移32位，然后取四字节的秒数</span>

        System.out.println(<span class="string">"v_time="</span>+Long.toHexString(v_time));
        System.out.println(<span class="string">"时间为："</span>+<span class="keyword">new</span> java.util.Date(v_time*<span class="number">1000</span>));
        System.out.println(<span class="string">"v_machine="</span>+v_machine);
        System.out.println(<span class="string">"inc="</span>+v_inc);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> 
    </span>{
        <span class="keyword">long</span> objectid;
        <span class="keyword">long</span> id1=<span class="number">0</span>,id2=<span class="number">0</span>;

        <span class="comment">//生成100000个MyUUID</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++)
        {
            objectid=ObjectID();
            System.out.println(<span class="string">"MyUUID="</span>+Long.toHexString(objectid));

            <span class="keyword">if</span> (i==<span class="number">0</span>)
                id1=objectid;
            <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">99999</span>)
                id2=objectid;
            <span class="keyword">else</span>;
        }

        System.out.println(<span class="string">"反向解析MyUUID..................."</span>);
        reverseObjectID(id1);
        reverseObjectID(id2);
    }
}
</code></pre>
      
      


    </div>
    
    <footer class="article-footer">
      
        <a data-url="http://liuziquan.github.io/2015/09/24/浅度解析MongoDB的ObjectID生成规则/" data-id="ciexw7xww00066smkq6y9cmru" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MongoDB/">MongoDB</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Hadoop基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/23/Hadoop基础/" class="article-date">
  <time datetime="2015-09-23T01:45:35.985Z" itemprop="datePublished">2015-09-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hadoop/">Hadoop</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/23/Hadoop基础/">Hadoop基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      

<!-- Table of Contents -->


        <p>#NoSQL学习模式</p>
<ul>
<li>基本概念</li>
<li>安装</li>
<li>数据类型与数据模型</li>
<li>与应用程序对接</li>
<li>Shell操作命令</li>
<li>主从复制</li>
<li>分片</li>
<li>管理维护</li>
<li>应用案例</li>
</ul>
<p>4e7020cb7cac81af7136236b</p>
<p>1 001 001 101 010 001<br>111521</p>
<p>1001 0011 0101 0001<br>9351</p>
<p>4e7020cb7cac81af7136236b</p>

      
      


    </div>
    
    <footer class="article-footer">
      
        <a data-url="http://liuziquan.github.io/2015/09/23/Hadoop基础/" data-id="ciexw7xv900006smkvwtqrj3s" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hadoop/">Hadoop</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DB2 备份与恢复性能优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/18/DB2 备份与恢复性能优化/" class="article-date">
  <time datetime="2015-09-17T16:00:00.000Z" itemprop="datePublished">2015-09-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB2/">DB2</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/18/DB2 备份与恢复性能优化/">DB2 备份与恢复性能优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      

<!-- Table of Contents -->


        <p>本文转载自IBM工程师孙岳的<a href="http://www.ibm.com/developerworks/cn/data/library/techarticles/dm-1002suny/#icomments" target="_blank" rel="external">DB2 备份与恢复性能优化及其在 SAP 系统中的实践</a>。<br>转载目的：</p>
<ol>
<li>文章确实写好，对于DB2的备份恢复学习很有帮助，非常感谢孙岳</li>
<li>用于Markdown练手，学习行文格式</li>
</ol>
<hr>
<p>本文以基于 DB2 的 SAP 系统为例,详细介绍了 DB2 备份和恢复的工作原理,以及 DB2 备份和恢复中可以调整的优化参数,并通过 SAP 客户备份和恢复实例来进一步说明如何优化 DB2 备份与恢复的性能,最后讨论了在不同容量下的数据库备份和恢复策略。</p>
<h2 id="DB2_备份和恢复简介">DB2 备份和恢复简介</h2><p>数据库运行过程中可能会遇到诸如存储介质损坏，服务器故障，供电中断等不可预测的问题导致数据丢失或损毁。因此，采取一定备份和恢复策略就显的尤为重要。随着企业用户数据量的不断增长，如何快速而有效的对数据进行备份和恢复，就成为数据库日常维护的重要议题。这也是本文讨论的重点。</p>
<p>下面我们简单介绍 DB2 提供的数据库备份和恢复的方法和命令。DB2 数据库通过 BACKUP DATABASE 和 RESTORE DATABASE 命令来进行数据库的备份和恢复。例如：</p>
<pre><code>db2 “<span class="operator"><span class="keyword">backup</span> <span class="keyword">database</span> HIA <span class="keyword">online</span> <span class="keyword">to</span> <span class="keyword">E</span>:\<span class="keyword">backup</span> <span class="keyword">compress</span> <span class="keyword">include</span> <span class="keyword">logs</span>”
db2 “<span class="keyword">restore</span> <span class="keyword">database</span> HIA <span class="keyword">from</span> <span class="keyword">E</span>:\<span class="keyword">backup</span>”</span>
</code></pre><p>DB2 的备份和恢复命令已经被集成进 DB2 引擎。它能够提供不同粒度和不同级别的备份和恢复：</p>
<ul>
<li>完整的数据库或者某个表空间的备份与恢复</li>
<li>离线或在线的数据库备份</li>
<li>完整、增量或者 delta 方式的数据库备份与恢复</li>
</ul>
<p>同时，DB2 备份和恢复命令还具有一系列的参数用来调整数据库备份和恢复的效率。例如我们可以通过 UTIL_IMPACT_PRIORITY 参数来调整 DB2 在备份过程中的 CPU 占用率。由于 DB2 备份恢复的参数优化与 DB2 备份和恢复的进程模型具有密切的关系，所以我们首先来看一下 DB2 备份和恢复的工作原理。</p>
<h2 id="DB2_备份和恢复的工作原理">DB2 备份和恢复的工作原理</h2><p>DB2 备份和恢复主要由两种不同的 EDU 共同完成数据库的备份和恢复操作。其中 db2bm（备份和恢复缓冲区操纵程序）用来在表空间和系统缓存间进行数据传输，db2med（备份和恢复介质控制器）用来在系统缓存和外部介质之间进行数据传输。db2bm 和 db2med 均在 db2agent 的协调下进行工作。其中，db2bm 需要通过 db2pfchr（缓冲池预取进程）从容器中预取数据，或者通过 db2pclnr（缓冲池页清楚程序）向容器中写入数据。在 DB2 V9.5 版本之前，db2bm 和 db2med 是以进程方式存在于内存中，而在 DB2 V9.5 版本后改为线程方式。DB2 备份进程模型如下图1所示。<br><img src="/images/image001.gif" alt="图 1. DB2 备份进程模型"></p>
<p>以 DB2 备份为例，从图中我们可以看出，其存在 3 个表空间（tablespace1，tablespace2，tablespace3）和 3 个外部存储介质。第一个 db2bm 进程负责从 tablespace1 和 tablespace2 中顺次读取数据，并将它们写入到系统缓存中。即 db2bm 进程会首先对 tablespace1 进行备份，当备份完成后，db2bm 会开始对 tablespace2 的备份。第二个 db2bm 进程负责从 tablespace3 中读取数据并写入系统缓存。同时，每一个外部存储介质对应于一个 db2med 进程，db2med 进程负责将系统缓存中的数据写入到外部设备中。</p>
<p>DB2 恢复过程与 DB2 备份过程类似，在这里就不再重复解释。如下图 2 所示。<br><img src="/images/image002.gif" alt="图 2. DB2 恢复进程模型"></p>
<p>对于 DB2 备份和恢复过程来说，在 EDU 内部，DB2 并不会控制 db2bm 进程从表空间往系统缓存的写入或读取速度，同样的，db2med 进程在系统缓存和外部介质之间的传输速度也不会受到限制。DB2 备份和恢复工具会以尽可能快的速度向外部介质写入和读取数据。我们只能够通过外部参数 UTIL_IMPACT_PRIORITY 对 DB2 备份和恢复进行整体控制。</p>
<p>在 DB2 备份和恢复过程中，每一个表空间都会由一个单独的 db2bm 进程负责读取与写入。如图 1 所示，如果备份过程中存在有 2 个 db2bm 进程，那个其中一个 db2bm 进程会负责对其中的两个表空间进行读写操作。并且这 2 个 db2bm 进程会并行的对表空间进行读写操作，如 tablespace1 和 tablespace3 中的数据会由不同的 db2bm 并行写入到系统缓存。db2bm 的数量可以有 PARALLELISM 参数进行指定，如下。</p>
<pre><code>db2 <span class="operator"><span class="keyword">backup</span> <span class="keyword">database</span> <span class="keyword">to</span> <span class="keyword">d</span>:\<span class="keyword">backup</span> PARALLELISM <span class="number">4</span>
db2 <span class="keyword">restore</span> <span class="keyword">database</span> <span class="keyword">from</span> <span class="keyword">d</span>:\<span class="keyword">backup</span> PARALLELISM <span class="number">4</span></span>
</code></pre><p>同理，我们可以通过如下的方式指定 db2med 的数目。</p>
<pre><code>db2 <span class="operator"><span class="keyword">backup</span> <span class="keyword">database</span> <span class="keyword">to</span> <span class="keyword">d</span>:\<span class="keyword">backup</span> <span class="keyword">e</span>:\<span class="keyword">backup</span> <span class="keyword">f</span>:\<span class="keyword">backup</span>
db2 <span class="keyword">restore</span> <span class="keyword">database</span> <span class="keyword">from</span> <span class="keyword">d</span>:\<span class="keyword">backup</span> <span class="keyword">e</span>:\<span class="keyword">backup</span> <span class="keyword">f</span>:\<span class="keyword">backup</span></span>
</code></pre><p>DB2 会根据我们所指定的目标路径的数据来生成对应数据的 db2med 进程。</p>
<h2 id="DB2_备份和恢复的优化参数">DB2 备份和恢复的优化参数</h2><p>本节我们将详细介绍影响 DB2 备份和恢复的优化参数，并结合工作原理解释它们的具体含义，并给出性能优化建议。</p>
<h3 id="BACKUP_优化参数">BACKUP 优化参数</h3><p>在 DB2 备份命令中有如下参数可以用来调整数据库备份的性能。</p>
<pre><code><span class="operator"><span class="keyword">BACKUP</span> <span class="keyword">DATABASE</span> &lt;DB&gt; <span class="keyword">TO</span> dir | dev <span class="keyword">WITH</span> <span class="keyword">num</span>-buf BUFFERS 
BUFFER buff-<span class="keyword">size</span> PARALLELISM <span class="keyword">n</span> <span class="keyword">COMPRESS</span> 
UTIL_IMPACT_PRIORITY <span class="keyword">priority</span></span>
</code></pre><p><strong>PARALLELISM n</strong></p>
<p>通过使用 PARALLELISM 参数指定了使用 db2bm 进程数目，它决定了从表空间中往系统缓存中写入的并行性。每一个 db2bm 进程会对应于一个或多个表空间，当一个 db2bm 进程完成对当前表空间的备份后，它会继续对另外一个表空间进行备份。由于每一个 db2bm 进程至少对应于一个表空间，因此 PARALLELISM 值需要小于数据库表空间的数目，如果将设置 PARALLELISM 为大于数据库中表空间的数目，其并不会显著提高备份的性能。</p>
<p><strong>To dir | dev</strong></p>
<p>如果有多个目标路径被指定，如 To dir1, dir2, dir3，则可以指定备份时使用的 db2med 的进程数目。多个 db2med 进程会并行的像 dir1, dir2, dir3 中写入数据，其实第一个目标路径 dir1 中会保存备份数据的数据头以及一些特殊的文件。</p>
<p>如果系统中有多个磁盘系统，可以使用多个目标路径分别指向这些磁盘系统，以提高往磁盘写入数据的并行性。</p>
<p><strong>BUFFER buff-size</strong></p>
<p>使用 BUFFER buff-size 参数可以指定内部缓存的大小，如图 1 中的内部缓存（Utility Heap），单位为 4KB。如果 BUFFER 的值没有指定，则使用 dbm 中的参数 BACKBUFSZ 作为内部缓存的大小。进行备份时，数据首先由表空间写入内部缓存，当缓存满后，缓存中的数据会被写入到外部磁盘中。</p>
<p>BUFFER 值的大小建议设置为 extent 大小的整数倍。如果不同的表空间的 extent 大小不同，则 BUFFER 值建议为它们的最小公倍数。</p>
<p><strong>WITH num-buf BUFFERS</strong></p>
<p>如图 1 所示，每一个备份过程可以拥有一个或者多个内部缓存。将内部缓存的数目设置为至少 db2med 进程的 2 倍能够有效的提高备份时的速度，它使得 db2med 进程向外部磁盘写入数据时无需等待缓存。</p>
<p>同时需要注意的是，(BUFFER buff-size) * (WITH num-buf BUFFERS) &lt; UTIL_HEAP_SZ。UTIL_HEAP_SZ 指定了 DB2 中实用程序堆的大小，此参数指定可由备份、复原和装入（包括装入恢复）实用程序同时使用的最大内存量。</p>
<p><strong>UTIL_IMPACT_PRIORITY</strong></p>
<p>UTIL_IMPACT_PRIORITY 可以用来调节备份的速度，其取值在 1 到 100 之间。1 代表最低优先级，100 代表最高优先级。如果此参数不指定，则备份进程会以最快的速度备份数据。</p>
<p><strong>COMPRESS</strong></p>
<p>备份压缩功能能够在数据写入外部磁盘前，对内部缓存中的数据进行压缩，从而减少备份文件的大小。其使用的是一种改进的 Lempel-Zev（LZ）算法。</p>
<p>通过开启数据压缩功能，我们可以节省存储备份的磁盘空间。例如，在下面的例子中，我们将 SAP 的备份的容量从 89GB 缩小到 13GB。</p>
<h2 id="RESTORE_优化参数">RESTORE 优化参数</h2><p>在 DB2 恢复命令中有如下参数可以用来调整数据库恢复的性能。</p>
<pre><code><span class="operator"><span class="keyword">RESTORE</span> <span class="keyword">DATABASE</span> &lt;DB&gt; <span class="keyword">FROM</span> dir | dev <span class="keyword">WITH</span> <span class="keyword">num</span>-buf 
BUFFERS BUFFER buff-<span class="keyword">size</span> PARALLELISM <span class="keyword">n</span></span>
</code></pre><p><strong>PARALLELISM n</strong></p>
<p>与 DB2 备份命令相同，PARALLELISM 参数用来指定在恢复过程中的 db2bm 的数目。通过增加 PARRALLELISM 值可以提高数据在内部缓存和表空间之间的并行性。</p>
<p><strong>FROM dir | dev</strong></p>
<p>如果指定多个备份存储路径，（其取决于备份时目标路径的数目）如 From dir1, dir2, dir3，则可以指定恢复时 db2med 进程数目的多少，从而加快数据从外部介质写入内部缓存的速度。</p>
<p><strong>BUFFER buf-size</strong></p>
<p>BUFFER buf-size 的大小为一块内部缓存的大小，其应该设置为 extent 大小的整倍数，同时需要等于或者为备份时所定义大小的整倍数。如果没有设置的话，则使用 dbm 中的 RESTBUFSZ 参数作为内部缓存的大小。</p>
<p><strong>WITH num-buff BUFFERS</strong></p>
<p>指定使用的内部缓存的大小，同备份参数相同，其最好设置为 db2med 的 2 倍以提高备份的速度。同时 (BUFFER buff-size) * (WITH num-buf BUFFERS) &lt; UTIL_HEAP_SZ。</p>
<p>我们可以看到，通过调整 DB2 备份和恢复的参数，我们可以根据当前系统所处的不同硬件环境调整数据库备份和恢复过程中的 db2bm（备份和恢复缓冲区操纵程序）和 db2med（备份和恢复介质控制器）的数目，以及它们在备份和恢复过程中使用的内部缓存的大小和数目等参数，从而提高 DB2 的整体备份和恢复性能。</p>
<p>那么，在具体的环境中，我们如何利用这些参数以提高备份和恢复的性能，就成为我们下面讨论的重点。下一节我们以基于 DB2 的 SAP 系统为例，讨论如何在 SAP 系统中提高备份和恢复的性能，进一步详细说明性能参数在数据库备份和恢复中的影响。</p>
<h2 id="实例_–_在_SAP_系统中进行快速有效的备份和恢复">实例 – 在 SAP 系统中进行快速有效的备份和恢复</h2><p>本节以基于 DB2 的 SAP 系统的备份和恢复为例，通过备份恢复时间，数据库备份和恢复参数的调整与比较等，进一步说明性能参数在数据库备份和恢复中的影响。下文进行备份和恢复的系统硬件环境为 AMD 4 核 CPU，8GB 内存，2 块 IBM SCSI 磁盘作为备份介质，而 SAP 数据库存储在另外 1 块 RAID5 磁盘上。<br>SAP 系统的备份</p>
<p>通常，SAP 管理员会通过 SAP 中的 DBACockpit 中的 DBA Planning Calendar 对 SAP 的数据库进行备份，或者可以通过业务代码 DB13 直接进入到 DBA Planning Calendar 页面。在 DBA Planning Calendar 里选取 Database Backup to Device 弹出选择画面，如图 3 所示。<br><img src="/images/image003.jpg" alt="图 3. Database Backup to Device 备份选择页面"></p>
<p>从选择页面中我们可以看到，其提供了备份方式（Backup Mode），备份类型（Backup Type）的选择（关于备份方式和备份类型我们在这里不进行深入的讨论）。其他参数的对应关系如下：</p>
<ul>
<li>压缩（Compress）：对应于 DB2 备份命令中的 COMPRESS 参数。</li>
<li>内部缓存数目（Number of Buffers）：对应于 DB2 备份命令中的 WITH num-buff BUFFERS。</li>
<li>内部缓存大小（Buffer Size）：对应于 DB2 备份命令中的 BUFFER buf-size，在这里以页为单位（4 KB）。</li>
<li>并行数目（Parallelism）：对应于 DB2 备份命令中的 PARALLELISM 参数，通过指定该参数可以调整 db2bm 的数目。</li>
<li>优先级（Priority）：对应于 DB2 备份命令中的 UTIL_IMPACT_PRIORITY，通过它我们可以控制 DB2 进行备份的速度。</li>
<li>目标路径（Device/Directory）：对应于 DB2 备份命令中的 To dir | dev，通过指定多个目标路径我们可以调整 db2med 的数目。</li>
</ul>
<p>上面我们已经知道系统具体的硬件环境为 4 核 AMD CPU，8GB 内存，2 块 IBM SCSI 磁盘。那么下面我们通过几组不同的参数比较，来对比一下在不同参数下的 DB2 备份性能。</p>
<p>在备份时，比较明显的提高备份速度的方法是改变 PARALLELISM 的值，如我们分别用表 1 中的参数通过 SAP 备份工具进行备份，其中 PARALLELISM 分别等于 2，4 和 8。运行结果如下图 4 所示。从图中我们可以看到，当我们使用 PARALLELISM 为 2 进行备份时，完成整个在线备份的时间大约为 1 个小时。而当使用 PARALLELISM 为 8 时，我们可以将在线备份的时间缩短到 40 分钟左右。因此，通过增加 PARALLELISM 的参数值在一定程度上是可以提高备份速度。</p>
<p>但是，这也并不意味着 PARALLELISM 的值越大越好。我们需要考虑 CPU 的负载能力。例如在本例中，当我们把 PARALLELISM 的值增加到 16 时，备份时间反而增加到 72 分钟。</p>
<h3 id="表_1-_PARALLELISM_参数值">表 1. PARALLELISM 参数值</h3><table>
<thead>
<tr>
<th>Parallelism</th>
<th>Number of Buffers / Buffer Size</th>
<th>Device / Directory</th>
<th>Compress</th>
<th>Priority</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>8 / 1024</td>
<td>D:\backup</td>
<td>Y</td>
<td>100</td>
</tr>
<tr>
<td>4</td>
<td>8 / 1024</td>
<td>D:\backup</td>
<td>Y</td>
<td>100</td>
</tr>
<tr>
<td>8</td>
<td>8 / 1024</td>
<td>D:\backup</td>
<td>Y</td>
<td>100</td>
</tr>
</tbody>
</table>
<p><img src="/images/image004.gif" alt="图 4. SAP 数据库备份时间 – 调整 PARALLELISM"></p>
<p>同样，我们也可以通过增加备份的路径数目来提高备份效率。其备份时的参数和结果如下表 2 和图 5 所示。通过结果可以看出，我们也可以通过增加磁盘数目，从而提高磁盘在单位时间内的 I/O 数，来达到提高备份速度的目的。</p>
<h3 id="表_2-_To_dir_|_dev_参数值">表 2. To dir | dev 参数值</h3><table>
<thead>
<tr>
<th>Parallelism</th>
<th>Number of Buffers / Buffer Size</th>
<th>Device / Directory</th>
<th>Compress</th>
<th>Priority</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>8 / 1024</td>
<td>D:\backup</td>
<td>Y</td>
<td>50</td>
</tr>
<tr>
<td>1</td>
<td>8 / 1024</td>
<td>D:\backup, F:\backup</td>
<td>Y</td>
<td>50</td>
</tr>
</tbody>
</table>
<p><img src="/images/image005.gif" alt="图 5. SAP 数据库备份时间 – 多个存储路径备份"></p>
<p>另外，通过使用压缩功能也可以提高数据库的备份速度。如下图 6 所示。从图中我们可以看到，采用压缩功能的备份时间要远远小于不压缩的备份时间。由于 DB2 数据压缩功能是在备份时由数据库对缓存中的数据进行实时的压缩，例如：</p>
<ul>
<li>采用压缩的备份文件约为 13 GB</li>
<li>不采用压缩的备份文件约为 89 GB</li>
</ul>
<p>因此它可以有效减小备份文件的大小，即它也减小了备份时对磁盘 I/O 的请求数，因此提高了备份的效率。<br><img src="/images/image006.gif" alt="图 6. SAP 数据库备份时间 – 压缩和非压缩"></p>
<h3 id="SAP_系统的恢复">SAP 系统的恢复</h3><p>在企业应用中进行数据库恢复，通常是当系统出现故障或者其他意外情况导致系统不可用。那么这时就需要我们能够快速的将 SAP 数据库恢复，以减少业务损失。因此，通过调整 RESTORE 参数来提高恢复性能就成为我们十分重要的选择。</p>
<p>我们通过以下的一些实验数据来对调整 RESTORE 参数进行进一步的说明。硬件环境与备份系统的环境相同。</p>
<p>当我们进行 SAP 数据库恢复时，我们可以通过改变 PARALLELISM 的值来提高 DB2 数据库恢复的速度。如图 7 所示，通过如下命令对 SAP 系统的数据库分别进行恢复。我们可以看到，当 PARALLELISM 设置为 8 时（即系统中有 8 个 db2bm 进程同时从表空间读取数据）的恢复时间几乎为 PARALLELISM 等于 1 时的一半。</p>
<pre><code><span class="operator"><span class="keyword">RESTORE</span> <span class="keyword">DATABASE</span> HIA <span class="keyword">FROM</span> <span class="keyword">d</span>:\bkup <span class="keyword">WITH</span> <span class="number">8</span> BUFFERS BUFFER <span class="number">1024</span> PARALLELISM
<span class="keyword">RESTORE</span> <span class="keyword">DATABASE</span> HIA <span class="keyword">FROM</span> <span class="keyword">d</span>:\bkup <span class="keyword">WITH</span> <span class="number">8</span> BUFFERS BUFFER <span class="number">1024</span> PARALLELISM
<span class="keyword">RESTORE</span> <span class="keyword">DATABASE</span> HIA <span class="keyword">FROM</span> <span class="keyword">d</span>:\bkup <span class="keyword">WITH</span> <span class="number">8</span> BUFFERS BUFFER <span class="number">1024</span> PARALLELISM</span>
</code></pre><p><img src="/images/image007.gif" alt="图 7. SAP 数据库恢复时间 – 调整 PARALLELISM"></p>
<p>另外，我们也可以通过从多个存储路径中进行数据库恢复，从而提高数据库的恢复速度。如下图 8 所示。我们通过如下的命令从备份文件中恢复数据库。从图 7 中的数据我们可以看出，同时从两个不同的磁盘目录中进行恢复的速度在一定程度上要优于从单一磁盘目录中进行恢复。其原因是在同一时刻，我们可以通过多个磁盘来获取更多的 I/O 数，从而提高备份数据从磁盘读取的速度。但是，这也取决于磁盘每秒钟的 I/O 数和磁盘传输数据的速度，因此，在某些情况下，从多个不同磁盘目录中恢复数据不一定要优于从单一磁盘中恢复。</p>
<pre><code><span class="operator"><span class="keyword">RESTORE</span> <span class="keyword">DATABASE</span> HIA <span class="keyword">FROM</span> <span class="keyword">d</span>:\bkup
<span class="keyword">RESTORE</span> <span class="keyword">DATABASE</span> HIA <span class="keyword">FROM</span> <span class="keyword">d</span>:\bkup, <span class="keyword">f</span>:\bkup</span>
</code></pre><p><img src="/images/image008.gif" alt="图 8. SAP 数据库恢复时间 – 从多个存储路径恢复"></p>
<h2 id="不同容量下的_DB2_备份和恢复策略">不同容量下的 DB2 备份和恢复策略</h2><p>上面我们通过 SAP 系统的备份和恢复实例给出了在不同参数下的 DB2 数据库的备份和恢复性能。但是在企业的实际应用中，通过调整 DB2 的备份和恢复参数不一定能够达到理想的效果。通常，对于不同容量的数据库，我们也需要制定不同的数据库备份和恢复策略，使得我们能够对数据库进行快速的备份和恢复。SAP 推荐的 DB2 数据库备份恢复策略如下图 9 所示。</p>
<p>从下图我们可以看到，SAP 的恢复策略按容量分为小规模应用，中等规模容量，大容量以及极大规模应用：</p>
<ul>
<li>对于开发和测试的 SAP 数据库，我们只需要每周对其进行一次在线备份即可。</li>
<li>对于中等规模容量的 SAP 生产系统来说，则我们需要每天进行在线备份。由于它的数据库大小有限，所以一般来说，我们在几个小时之内可以完成对它的在线备份。</li>
<li>当数据库容量上升到大规模应用时，那么每天进行在线备份就不是一个好的解决方案。在这种情况下，我们可能很难在几个小时之内完成对数据库的备份，并且会影响到白天正常的业务运转。因此，在每天使用增量备份（Incremental Backup）就成为一种好的选择，它可以减少所需备份的数据量，从而提高备份的速度。同时，我们需要在每个周末进行一次在线备份来对数据库进行完整的备份。</li>
<li>当数据库容量继续上升后，使用增量备份也难以对数据库进行快速的备份，那么这时我们就需要使用分割镜像（Split Mirror）技术对数据库进行实时的备份。<br><img src="/images/image009.gif" alt="图 9. SAP 数据库备份恢复策略"></li>
</ul>
<h2 id="结束语">结束语</h2><p>本文介绍了 DB2 数据库备份和恢复的基本工作原理，并对 DB2 数据库备份和恢复的优化参数进行了详细的解释，同时通过在 SAP 系统中对 DB2 数据库的备份和恢复的实例，进一步说明了通过调整优化参数，能够提高在大数据容量下的数据库备份和恢复效率。最后，我们也给出了在不同数据库容量下的数据库备份和恢复策略，供需要规划 SAP 和 DB2 系统备份和恢复的读者参考。</p>
<h2 id="参考资料">参考资料</h2><h3 id="学习">学习</h3><ul>
<li>通过 <a href="http://www.ibm.com/developerworks/cn/data/" target="_blank" rel="external">developerWorks Information Management</a> 专区 学习关于 Information Management 的更多知识。在这里可以找到技术文档、how-to 文章、培训、下载、产品信息等等。</li>
<li>通过 Information Management 专区 <a href="http://www.ibm.com/developerworks/cn/data/v9/" target="_blank" rel="external">DB2 9 技术资源中心</a> 了解 DB2 产品家族的更多产品信息和相关技术。</li>
<li>通过 <a href="http://publib.boulder.ibm.com/infocenter/db2luw/v9r7/index.jsp" target="_blank" rel="external">DB2 V9.7 信息中心</a>，了解 DB2 的详细产品信息和相关技术等全面的内容。</li>
<li>通过 <a href="http://www.ibm.com/developerworks/cn/data/library/techarticles/pworld/0112mccluney.html" target="_blank" rel="external">执行数据库备份、恢复和前滚</a>，提供了执行数据库备份、恢复和前滚日志文件这些基本操作的循序渐进指南。</li>
<li>通过 <a href="http://www.ibm.com/developerworks/cn/data/library/techarticles/dm-0407tham/" target="_blank" rel="external">IBM DB2 UDB 与 Oracle 的备份和恢复</a>：介绍了 DB2 与 Oracle 数据库中如何进行备份和恢复。</li>
<li>通过 <a href="http://www.ibm.com/developerworks/cn/data/library/techarticles/pworld/0112mccluney.html" target="_blank" rel="external">执行数据库备份、恢复和前滚</a>，提供了执行数据库备份、恢复和前滚日志文件这些基本操作的循序渐进指南。</li>
<li>通过 <a href="http://www.ibm.com/developerworks/cn/data/library/techarticles/dm-0501zikopoulos/" target="_blank" rel="external">DB2 基础: IBM DB2 Universal Database for Linux, UNIX and Windows 备份实用程序</a>，介绍了 DB2 备份工具的原理和使用方法。</li>
<li>参考“<a href="http://www.ibm.com/software/data/db2/sap/" target="_blank" rel="external">IBM DB2 database and SAP software</a>”，了解更多 DB2 SAP 相关内容。</li>
<li>通过 <a href="http://www.sdn.sap.com/irj/sdn/db6" target="_blank" rel="external">SAP on DB2 for LUW</a>：获得关于 DB2 LUW for SAP 的技术资源及相关文章。</li>
<li>随时关注 developerWorks <a href="http://www.ibm.com/developerworks/cn/offers/techbriefings/" target="_blank" rel="external">技术活动</a> 和 <a href="http://www.ibm.com/developerworks/cn/swi/" target="_blank" rel="external">网络广播</a>。</li>
</ul>
<h3 id="获得产品和技术">获得产品和技术</h3><ul>
<li>使用可直接从 developerWorks 下载的 IBM 产品评估试用软件 构建您的下一个开发项目。</li>
<li>现在可以免费使用 DB2。下载 DB2 Express-C，这是为社区提供的 DB2 Express Edition 的免费版本，它提供了与 DB2 Express Edition 相同的核心数据特性，为构建和部署应用程序奠定了坚实的基础。</li>
</ul>
<h3 id="讨论">讨论</h3><ul>
<li>通过 SAP COMMUNITY NETWORK：获得 SAP 家族产品和文档资源。</li>
<li>通过 SAP SERVICES MARKETPLACE：获得 SAP 产品和服务。SAP 客户可以通过 SAP 客户 ID 访问 SAP NOTES。</li>
<li>参与 developerWorks blogs 并加入 developerWorks 中文社区，查看开发人员推动的博客、论坛、组和维基，并与其他 developerWorks 用户交流。</li>
</ul>

      
      


    </div>
    
    <footer class="article-footer">
      
        <a data-url="http://liuziquan.github.io/2015/09/18/DB2 备份与恢复性能优化/" data-id="ciepb617h00003cmky9mgfpfh" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB2/">DB2</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DB2的备份（backup）和恢复（RESTORE）数据库方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/18/DB2的备份（backup）和恢复（RESTORE）数据库方法/" class="article-date">
  <time datetime="2015-09-17T16:00:00.000Z" itemprop="datePublished">2015-09-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DB2/">DB2</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/18/DB2的备份（backup）和恢复（RESTORE）数据库方法/">DB2的备份（backup）和恢复（RESTORE）数据库方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      

<!-- Table of Contents -->


        <p>本文转载自ＱＱ天堂<a href="http://www.cnblogs.com/QQParadise/articles/2376488.html" target="_blank" rel="external">DB2的备份（backup）和恢复（RESTORE）数据库方法</a></p>
<h2 id="一、备份（backup）数据库">一、备份（backup）数据库</h2><p>1、离线全备份</p>
<p>1）、首先确保没有用户使用DB2:<br>db2 list applications for db sample<br>2）、停掉数据库并重新启动，以便断掉所有连接：<br>db2stop force<br>db2start<br>3）、执行备份命令：（使用TSM作为备份的介质）<br>db2 backup db sample use tsm<br>备份成功，将会返回一个时间戳。<br>4）、检查备份成功：<br>db2 list history backup all for sample 可以看到多了这个备份的纪录。<br>db2adutl query 命令也可以看到返回值。<br>5）、备注：<br>首先对主节点（catalog表空间在的节点）执行备份命令，再对另外的节点也做这个操作。</p>
<p>2、 在线备份：</p>
<p>1）、首先打开一下支持在线备份的数据库配置参数：<br>db2 update db cfg for sample using userexit on 启用用户出口<br>db2 update db cfg for sample using logretain on 启用归档日志<br>db2 update db cfg for sample using trackmod on 启用增量备份功能<br>(需要各个Node都分别做设置)<br>开启这些参数后，数据库处于backup pending状态，要求做数据库的离线全备份。做一下离线全备份，参考上面的命令。<br>2）、在线备份命令如下：<br>db2 backup db sample online use tsm<br>备份成功，返回一个时间戳。<br>3）、同样可以用db2adutl 和db2 list history察看备份纪录。<br>4）、备注：<br>同样，对每个节点都做这个操作。</p>
<p>3、 在线增量备份</p>
<p>1）、在开启了必须的三个参数的情况下，做增量备份：<br>db2 backup db sample online incremental use tsm<br>备份成功，返回一个时间戳。<br>2）、同样可以用db2adutl 和db2 list history察看备份纪录。<br>3）、还有一种delta的备份：<br>db2 backup db sample online incremental delta use tsm<br>这两种备份的区别，类似Oracle Exports的Incremental和Cumulative方式，db2的incremental对应oracle的cumulative方式，而db2的delta方式则对应oracle的incremental方式。<br>4）、备注：<br>同样，对每个节点都做这个操作。</p>
<p>二、恢复（RESTORE）数据库</p>
<p>1、新建数据库</p>
<p>在一般管理工具， 创建数据库（别名要和原来的数据库别名一致）。</p>
<p>2、恢复数据库</p>
<p>1）：断开连接：将网络断开，切断所有的客户连接，如果不行，先重启。(如果有客户端连接到DB2服务器，恢复不行的，包括控制中心)</p>
<p>2）：恢复离线备份：<br>　　 设：<br>　　 你的备份那个DB2文件在：C:\Temp<br>　　 你的数据库名称：DBName<br>　　 那么对应DB2的备份/恢复文件的格式是这样的：<br>　　 C:\Temp\DBName.0\DB2CTLSV\NODE0000\CATN0000\20090706\HHMMSS.001</p>
<p>备份时你只是指定了一个C:\Temp目录，后面那么目录为DB2备份时生成。<br>　　 然后是它的文件名，一般格式是：HHMMSS.001,即:小时分钟秒数.001，也就是说后面那个20020828是备份日期，文件名是备份时间。<br>　　<br>　　 好，清楚后，你就可以写SQL命令进行恢复了<br>　　 运行: Start-&gt;Program-&gt;IBM DB2-&gt;Command Center<br>　　 然后：不要登陆，直接输入下列命令：<br>　　<br>以下为引用的内容：<br>RESTORE DATABASE NewDBName FROM C:\Temp\ TAKEN AT<br>20020919094932 TO D: INTO OldDBName WITH 2 BUFFERS BUFFER 1024<br>WITHOUT PROMPTING 　<br>　　你要改<br>　　NewDBName ==》你的新建数据库名称<br>　　C:\TEMP\ ==&gt; 你备份DB2的目录，像上面所说<br>　　20020919094932 ==&gt; 一看你DB2的目录和文件组合成这东东<br>　　D: ==&gt; 新建的数据库放在哪个盘上<br>　　OldDBName ==&gt; 备份前那个数据库叫什么<br>　　<br>　　好了，CTRL+ENTER， 如果不行请检查，如果再不行，请重启，如果再不行，。。。阿门，上帝保佑你</p>
<p>3）：实例<br>　　备份文件路径：C:\Temp\ipmdemo.0\DB2CTLSV\NODE0000\CATN0000\20090622\164642.001<br>其中，备份日期：20090622 备份文件：164642.001<br>　　新建数据库名：ipmdemo<br>　　数据库文件时间戳： 20090622164642</p>
<p>恢复命令为：db2 restore database ipmdemo from C:\Temp taken at 20090622164642</p>
<p>3、恢复在线备份</p>
<p>1）、恢复。恢复命令为：db2 restore database DBName from C:\Temp taken at 20090622164642</p>
<p>2）、前滚。前滚命令为：db2 rollforward db DBName to end of logs（或者：控制中心-&gt;所有数据库-&gt;dbname -&gt;右键-&gt;前滚）</p>
<p>3）、停止前滚。停止前滚命令为：db2 rollforward db DBName stop（或者：控制中心-&gt;所有数据库-&gt;dbname -&gt;右键-&gt;停止前滚）</p>
<p>三、有关说明</p>
<p>1、恢复操作也有online和offline的,区别如同backup的操作。<br>2、按照表空间的备份和恢复类似，加子句TABLESPACE ( tablespace-name )即可。表空间级别的备份/恢复操作要求数据库处于归档日志和启用增量备份模式下。<br>3、恢复的例子中只做了版本恢复。若还有更新的全备份和增量备份的image，可以依次做恢复（注意使用db2ckrst的建议恢复次序和次数）后，再做roll forward。</p>

      
      


    </div>
    
    <footer class="article-footer">
      
        <a data-url="http://liuziquan.github.io/2015/09/18/DB2的备份（backup）和恢复（RESTORE）数据库方法/" data-id="ciepf1b750000ckmk7o0fthqk" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB2/">DB2</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HBase入门实例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/11/HBase入门实例/" class="article-date">
  <time datetime="2015-09-10T16:00:00.000Z" itemprop="datePublished">2015-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/HBase/">HBase</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/11/HBase入门实例/">HBase入门实例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      

<!-- Table of Contents -->


        <h2 id="Table中Family和Qualifier的关系与区别">Table中Family和Qualifier的关系与区别</h2><p>就像用MySQL一样，我们要做的是表设计，MySQL中的表，行，列的在HBase已经有所区别了，在HBase中主要是Table和Family和Qualifier，这三个概念。Table可以直接理解为表，而Family和Qualifier其实都可以理解为列，一个Family下面可以有多个Qualifier，所以可以简单的理解为，HBase中的列是二级列，也就是说Family是第一级列，Qualifier是第二级列。两个是父子关系。</p>
<h2 id="谈谈Table中Family和Qualifier的设置">谈谈Table中Family和Qualifier的设置</h2><p>对于传统关系型数据库中的一张table，在业务转换到hbase上建模时，从性能的角度应该如何设置family和qualifier呢？<br>最极端的，可以每一列都设置成一个family，也可以只有一个family，但所有列都是其中的一个qualifier，那么有什么区别呢？<br>family越多，那么获取每一个cell数据的优势越明显，因为io和网络都减少了，而如果只有一个family，那么每一次读都会读取当前rowkey的所有数据，网络和io上会有一些损失。<br>当然如果要获取的是固定的几列数据，那么把这几列写到一个family中比分别设置family要更好，因为只需一次请求就能拿回所有数据。<br>以上是从读的方面来考虑的，那么写呢？可以参考一下这篇文章：<br><a href="http://hbase.apache.org/book/number.of.cfs.html" target="_blank" rel="external">http://hbase.apache.org/book/number.of.cfs.html</a></p>
<p>首先，不同的family是在同一个region下面。而每一个family都会分配一个memstore，所以更多的family会消耗更多的内存。<br>其次,目前版本的hbase，在flush和compaction都是以region为单位的，也就是说当一个family达到flush条件时，该region的所有family所属的memstore都会flush一次，即使memstore中只有很少的数据也会触发flush而生成小文件。这样就增加了compaction发生的机率，而compaction也是以region为单位的，这样就很容易发生compaction风暴从而降低系统的整体吞吐量。<br>第三，由于hfile是以family为单位的，因此对于多个family来说，数据被分散到了更多的hfile中，减小了split发生的机率。这是把双刃剑。更少的split会导致该region的体积比较大，由于balance是以region的数目而不是大小为单位来进行的，因此可能会导致balance失效。而从好的方面来说，更少的split会让系统提供更加稳定的在线服务。<br>上述第三点的好处对于在线应用来说是明显的，而坏处我们可以通过在请求的低谷时间进行人工的split和balance来避免掉。<br>因此对于写比较多的系统，如果是离线应该，我们尽量只用一个family好了，但如果是在线应用，那还是应该根据应用的情况合理地分配family。</p>
<p>HBase实例代码</p>
<pre><code><span class="comment">/**
 * Hbase 基本CRUD 样例代码   覆盖Put Get Delete checkAndPut checkAndDelete  Scan
 * 通过上面的各种操作的例子, 会基本覆盖Htable可以用的的所有方法
 * 这里不涉及Hbase 管理代码的操作
 * @author Administrator
 *
 */</span>
public class HbaseCRUDTest_New {
    private static org.apache.hadoop.conf.Configuration conf = null;
    private static HTablePool pool = null;
    private static HBaseAdmin admin = null;
    private static final int MAX_TABLE_COUNT = <span class="number">10</span>;

    @BeforeClass
    public static void before<span class="params">()</span>throws Exception{
        <span class="comment">/**服务器端缓存客户端的连接 是以conf为单位的（可能不准确：通常一个客户端
         * 连接过来, 服务器端会有一个线程与之对应, 缓存的是这个服务器端的线程）,
         * 所以最好不要到处创建conf实例, 一个就够了, 所有共用conf创建的到Hbase
         * 的连接和操作, 会共用一个连接  这样可以提高性能, 也会减小服务器端的压力
         * 实际上创建Htable pool admin都是通过HConnection接口的实现类（
         * HConnectionImplementation）来完成的, 多个HConnection会由
         * HConnectionManager来管理, 而conf是HConnectionImplementation的最
         * 重要的构造参数 , 上面就以conf 来 标识和替代Hconnection 可能会带来歧义
         * 以为conf就是连接本身
         */</span>
        conf = HBaseConfiguration.create<span class="params">()</span>;
        <span class="comment">//这是一个10台集群的daily 日常性能测试环境</span>
        conf.set<span class="params">(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"10.232.31.209,10.232.31.210,10.232.31.211"</span>)</span>;
        conf.set<span class="params">(<span class="string">"hbase.zookeeper.property.clientPort"</span>, <span class="string">"3325"</span>)</span>;
        <span class="comment">//conf.addResource("dataSource.xml");//也可以载入一个标准的Hbase配置文件</span>

        <span class="comment">/**HTable是非线程安全的  在多线程环境下使用HTablePool是一个好的解决方案,
         * 参数MAX_TABLE_COUNT 是 pool保持的每个Htable实例的最大数量  ,
         * 比如为10   如果有100个线程getTable() 同一张表   则他们会共用 pool中的该
         * 表的10个实例   有些可能要排队等 用完的要回收放回去
         * 使用的时候 就不要new Htable了, 直接从pool中取
         * 用完再putTable 放回去
         *
         * 在0.92以上的版本  则不用放回去   直接table.close() 即可    putTable 被标记
         * 为 @Deprecated.  0.90.2 版本使用 putTable 下面的代码都没有 做 这些操作
         * 避免 不同版本 出问题
         */</span>
        pool = new HTablePool<span class="params">(conf, MAX_TABLE_COUNT)</span>;
        admin = new HBaseAdmin<span class="params">(conf)</span>;
    }
    <span class="comment">/**
     * 注意一下：Put Get Delete Scan等操作的对象 都提供一个空的构造函数, 一般不要直接使用, 
     *          他们存在主要是在rpc传输的反序列化的时候要用到（了解Java RMI的应该很清楚）
     * @throws IOException
     * @throws InterruptedException
     */</span>
    @Test public void putTest<span class="params">()</span> throws IOException, InterruptedException{
        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        <span class="comment">//批量操作 共两种 底层都是调用  HConnection的processBatch方法(</span>
        <span class="comment">// table.batch(List&lt;Put&gt;) 和table.flushCommits()会直接调用)</span>

        <span class="comment">//首先  自动flush 关闭    就像 JDBC中的 auto_commit,  否则 加每一条 提交</span>
        <span class="comment">// 一次,影响性能     不过table.put(List&lt;Put&gt;) table.batch(List&lt;Row&gt;)不受这</span>
        <span class="comment">// 个影响, 设置false,只有当put总大小超过writeBufferSize 才提交  或者手工</span>
        <span class="comment">// table.flushCommits() （table.put(List&lt;Put&gt;)操作完成后会手工提交一次）,</span>
        <span class="comment">// writeBufferSize 也可以调整</span>
        table.setAutoFlush<span class="params">(<span class="literal">false</span>)</span>;
        <span class="comment">//writeBufferSize 默认为2M ,调大可以增加批量处理的吞吐量, 丢失数据的风险也会加大</span>
        table.setWriteBufferSize<span class="params">(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">5</span>)</span>;
        <span class="comment">//这样可以看到 当前客户端缓存了多少put</span>
        ArrayList&lt;Put&gt; putx = table.getWriteBuffer<span class="params">()</span>;

        <span class="comment">// 批量操作方法一,单一操作的批量 比如Htable.put delete get 都提供了List作</span>
        <span class="comment">// 为参数的批处理.   默认每10条 或List&lt;Put&gt;数据量 超过writeBufferSize 提交</span>
        <span class="comment">// 如果AutoFlush为true 一次性table.put(List&lt;Put&gt;)只提交一次</span>
        List&lt;Put&gt; puts = new ArrayList&lt;Put&gt;<span class="params">(<span class="number">10</span>)</span>;

        <span class="keyword">for</span> <span class="params">(int i = <span class="number">0</span>,len=<span class="number">10</span>; i &lt; len; i++)</span> {
            Put put = new Put<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-"</span>+i)</span>,new Date<span class="params">()</span>.getTime<span class="params">()</span>)</span>;
            put.add<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"name"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"value"</span>+i)</span>)</span>;
            <span class="comment">// 这里可以自定义添加时间戳, 默认就是当前时间(RegionServer服务器端的</span>
            <span class="comment">// 时间) 也可以自己定义, 多版本时候(默认3)比如想插入一条比现在最新的记</span>
            <span class="comment">// 录老的, 一些特殊情况下可能会有这种需求</span>
            put.add<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"email"</span>)</span>, System.currentTimeMillis<span class="params">()</span>,
                    Bytes.toBytes<span class="params">(<span class="string">"value"</span>+i+<span class="string">"@sina.com"</span>)</span>)</span>;
            <span class="comment">//也可以直接加入一个KeyValue,实际上底层就是存储为KeyValue的, 如果对</span>
            <span class="comment">// 底层较熟悉, 这种操行更加高效, 一般上面的就可以完成日常工作了</span>
            put.add<span class="params">(new KeyValue<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-"</span>+i)</span>, Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>,
                    Bytes.toBytes<span class="params">(<span class="string">"age"</span>)</span>,Bytes.toBytes<span class="params">(<span class="number">20</span>+i)</span>)</span>)</span>;
            puts.add<span class="params">(put)</span>;

            <span class="comment">//写操作日志  这个对性能影响比较大,  但有很重要, 如果设为true, 只要写</span>
            <span class="comment">// 成功, 就算 机器挂掉 也不会丢失,</span>
            put.setWriteToWAL<span class="params">(<span class="literal">false</span>)</span>;
            <span class="comment">/**
             * Put还有一些额外的东西
             */</span>
            <span class="comment">//put.has(family, qualifier,ts,value)</span>
            <span class="comment">//put 当前在内存中的大小  这个在setWriteBufferSize 可能会用到</span>
            <span class="comment">/**实际上底层是 这么干的（当然还有其他比如put数量对table.flushCommits()的触发）
             * for(Put put:puts){
             *  total+=put.heapSize();
             *  if(total&gt;=table.getWriteBufferSize())
             *      table.flushCommits();
             * }
             */</span>
            put.heapSize<span class="params">()</span>;
            <span class="comment">//put 中 每次调用add 底层都会添加一个KeyValue,这个是添加的KeyValue数量</span>
            put.size<span class="params">()</span>;

            <span class="comment">//判断put中是否已经存在了 给定的family qualifier ts value</span>
<span class="comment">//          put.has(family, qualifier)</span>
<span class="comment">//          put.has(family, qualifier, value)</span>
<span class="comment">//          put.has(family, qualifier, ts)</span>
<span class="comment">//          put.has(family, qualifier, ts, value)</span>

            <span class="comment">//下面的方法 从字面上基本上就可以知道</span>
            put.isEmpty<span class="params">()</span>;
            put.getRow<span class="params">()</span>;
            put.getRowLock<span class="params">()</span>;
            put.getLockId<span class="params">()</span>;
            put.numFamilies<span class="params">()</span>;

        }

        table.put<span class="params">(puts)</span>;
        table.flushCommits<span class="params">()</span>;
        System.out.println<span class="params">(table.get<span class="params">(new Get<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-1"</span>)</span>)</span>)</span>)</span>;
        admin.flush<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        System.out.println<span class="params">(table.get<span class="params">(new Get<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-1"</span>)</span>)</span>)</span>)</span>;

        <span class="comment">//批量操作方法一, 使用batch,可以混合各种操作 ( Put Delete Get 都是接口Row的实现)</span>
        <span class="comment">//主要 这个如果处理Put操作 是不会使用客户端缓存的   会直接异步的发送到服务器端</span>
        List&lt;Row&gt; rows = new ArrayList&lt;Row&gt;<span class="params">(<span class="number">10</span>)</span>;
        <span class="keyword">for</span> <span class="params">(int i = <span class="number">10</span>,len=<span class="number">20</span>; i &lt; len; i++)</span> {
            Put put = new Put<span class="params">(Bytes.toBytes<span class="params">(<span class="params">(<span class="string">"row-"</span>+i)</span>)</span>)</span>;
            put.add<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"name"</span>)</span>, Bytes.toBytes<span class="params">(<span class="params">(<span class="string">"value"</span>+i)</span>)</span>)</span>;
            put.add<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"email"</span>)</span>, Bytes.toBytes<span class="params">(<span class="params">(<span class="string">"value"</span>+i+<span class="string">"@sina.com"</span>)</span>)</span>)</span>;
            rows.add<span class="params">(put)</span>;
        }
        <span class="comment">//可以添加 删除操作   但是 最好不要把对同一行的Put Delete用batch操作 ,</span>
        <span class="comment">// 因为 为了更好的性能  发到服务器端操作的顺序  是会改变的   很有可能不是放入的顺序</span>
        rows.add<span class="params">(new Delete<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-9"</span>)</span>)</span>)</span>;
        table.batch<span class="params">(rows)</span>;

            <span class="comment">/**  一些需要注意的地方：
             * 1. 提交到服务器  处理如果出现问题  会从服务器端返回RetriesExhaustedWithDetailsException
             * 包含出错的原因 和重试的次数
             * 如果 服务器端还是操作失败 , 这些put还会缓存在客户端  等到下次buffer 被flush,
             * 注意  如果客户端挂掉了   这些数据是会丢失的
             * 当然如果是NoSuchColumnFamilyException只会重试一次 并且不会恢复
             * 下面的情况要注意了
             * table.put(puts); 是会抛出异常的,而且不会再提交  这样数据会丢失的
             * 捕获这个异常手工table.flushCommits() 可以确保已经写入缓存的还可以有可能写入成功
             * try {
                    table.put(puts);
                } catch (Exception e) {
                    table.flushCommits();
                }
             * table.flushCommits(); 也会有异常   也要捕获
             *
             * 2. 还时候 启用缓存   正常操作发生异常时候并不会被正常报出来, 有时候
             * 会等到buffer被flush后才报出来  这也是要注意的地方
             *
             * 3.在缓存中的puts 被发送到服务器端的顺序和服务器处理的顺序 是控制不
             * 到的, 如果想指定顺序 , 只能使用较小的批处理  强制他们按照批处理的顺序执行
             */</span>

        <span class="comment">/**
         * 完备的一条记录就是一个KeyValue 一个rowkey可能有多个KeyValue（比如
         * 多个版本, 一个版本是一条）
         * rowkey ColumnFamily  Column  TimeStamp Type Value
         * 其中的Type就是区别Put和Delete等操作的类别, 实际上Delete也是添加一条记录
         * （Hbase存储的HDFS文件是只读的, 更新用 添加+删除 组合完成, 删除实际上
         * 也是添加一条删除,实际操作都是添加,在Hbase Compact时候 合并数据时候会剔除标记为删除的rowkey）
         * 这种 增 改 删的一致性操作  在客户端给我们的操作带来了便利
         *
         * 实际上ColumnFamily Column的名字是会以byte的形式存储在数据中的,
         * 因此, 它们在设计的时候名字应该尽可能的短 这样可以节省不少的空间
         */</span>
    }

    <span class="comment">/**
     * Delete与Put一致 把全部的Put改成Delete  table.put --&gt;table.delete 就可以了,
     * 不过有些需要注意, 看下面
     */</span>
    @Test public void deleteTest<span class="params">()</span>{
        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        try {
            <span class="comment">//如果上面介绍的KeyValue 有点印象, 通过delete提供的构造函数可以知道</span>
            <span class="comment">//不指定会删除所有的版本</span>
            Delete delete = new Delete<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-1"</span>)</span>)</span>;
            table.delete<span class="params">(delete)</span>;
        } catch <span class="params">(Exception e)</span> {
            e.printStackTrace<span class="params">()</span>;
        }
    }
    <span class="comment">/**
     * 一些原子性操作   对于java并发工具包有所了解的 应该会知道 轻量级锁的核心就是CAS机制(Compare and swap),
     * 这里在概念上有些类似, 也可以类似于  SQL中  select 出来然后   insert or update的 操作  
     * Hbase这里可以保证他们在一个原子操作
     * 这个在高并发 场景下  更新值  是个好的选择
     * table.checkAndPut(row, family, qualifier, value, put)
     * table.checkAndDelete(row, family, qualifier, value, delete)
     * @throws IOException
     */</span>
    @Test public void atomicOP<span class="params">()</span> throws IOException{
        byte[] row = Bytes.toBytes<span class="params">(<span class="string">"row-12"</span>)</span>;
        byte[] family = Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>;

        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        <span class="comment">//操作成功会返回 true,否则false;  如果是个不存在的qualifier, 把value置为null  check是会成功的</span>
        Put put = new Put<span class="params">(row)</span>;
        put.add<span class="params">(family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"value12"</span>)</span>)</span>;
        <span class="comment">//check 和put是同一个row</span>
        boolean result1 = table.checkAndPut<span class="params">(row, family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>, null, put)</span>;  <span class="comment">//true</span>
        boolean result2 = table.checkAndPut<span class="params">(row, family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>, null, put)</span>;   <span class="comment">//false</span>

        Put put2 = new Put<span class="params">(row)</span>;
        put2.add<span class="params">(family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"value12"</span>)</span>)</span>;
        boolean result3 = table.checkAndPut<span class="params">(row, family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>,
                Bytes.toBytes<span class="params">(<span class="string">"value12"</span>)</span>, put2)</span>;  <span class="comment">//true</span>

        Put put3 = new Put<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-13"</span>)</span>)</span>;
        put3.add<span class="params">(family, Bytes.toBytes<span class="params">(<span class="string">"namex"</span>)</span>, Bytes.toBytes<span class="params">(<span class="string">"value13"</span>)</span>)</span>;
        boolean result4 = table.checkAndPut<span class="params">(row, family, Bytes.toBytes<span class="params">(<span class="string">"namex2"</span>)</span>,
                Bytes.toBytes<span class="params">(<span class="string">"value12"</span>)</span>, put3)</span>;  <span class="comment">//org.apache.hadoop.hbase.DoNotRetryIOException</span>
        <span class="comment">//注意：check 和put的一定要是同一行 否则会报错</span>

<span class="comment">//      table.checkAndDelete类似</span>
    }

    <span class="comment">/**
     * 上面的一些操作有些方法可能涉及到Row Locks 但并没有说明   这里详细介绍下
     *
     * 一些会使数据发生变化的操作  比如like put(), delete(), checkAndPut()等等 , 操作都是以一个row为单位的,
     * 使用row lock 可以保证  一次性只能有一个客户端修改一个row
     * 虽然 实践中  客户端应用程序 并没有明确的使用lock, 但服务端会在适当的时机保护每一个独立的操作
     *
     * 如果可能应当尽量避免使用lock, 就像RSBMS一样会有死锁问题
     * @throws IOException
     */</span>
    @Test public void rowLocksTest<span class="params">()</span> throws IOException{
        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        byte[] row = Bytes.toBytes<span class="params">(<span class="string">"row-8"</span>)</span>;
        RowLock lock = table.lockRow<span class="params">(row)</span>;
        <span class="comment">//.....相关操作</span>
        table.unlockRow<span class="params">(lock)</span>;
        <span class="comment">//锁有效时间 默认时间是1分钟</span>
    }

    @SuppressWarnings<span class="params">(<span class="string">"deprecation"</span>)</span>
    @Test public void getTest<span class="params">()</span>{
        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        Get get = new Get<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-10"</span>)</span>)</span>;
        <span class="comment">//默认 get 只会取得最新的记录, 使用下面的方法可以获取其他的版本</span>
        <span class="comment">//有两个方法 一个带参数的可以指定版本数量, 可能会抛出异常;另外一个没有</span>
        <span class="comment">// 参数, 默认Integer.MAX_VALUE, 不会抛出异常</span>
        get.setMaxVersions<span class="params">()</span>;
    <span class="comment">//  get.setFilter(filter); get 一般数据比较少比较少使用filter, 在Scan的时候会详细介绍Filter</span>
        <span class="comment">//通过get.addColumn提供了各种重载方法, 可以过滤只获取哪些ColumnFamily</span>
        <span class="comment">// 和Column,get实现这种过滤只能使用这种方法, 接下来的Scan还可以使用Filter来实现</span>
        get.addColumn<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"data"</span>)</span>,Bytes.toBytes<span class="params">(<span class="string">"email"</span>)</span>)</span>;

        try {
            Result result = table.get<span class="params">(get)</span>;
            <span class="comment">//这是一个简单的 获取返回结果的方法, 还有其他的通过遍历Map的方式</span>
            List&lt;KeyValue&gt; values = result.list<span class="params">()</span>;
            <span class="comment">//由于KeyValue靠近底层, 对于一些一些Offset,Length结尾的方法 可以忽略,</span>
            <span class="comment">// 比较感兴趣的可以关注下Hbase的底层存储</span>
            <span class="keyword">for</span> <span class="params">(KeyValue keyValue : values)</span> {
                StringBuilder sb = new StringBuilder<span class="params">(Bytes.toString<span class="params">(keyValue.getFamily<span class="params">()</span>)</span>)</span>;
                sb.append<span class="params">(<span class="string">":"</span>)</span>.append<span class="params">(Bytes.toString<span class="params">(keyValue.getQualifier<span class="params">()</span>)</span>)</span>.append<span class="params">(<span class="string">"--:"</span>)</span>;
                sb.append<span class="params">(Bytes.toString<span class="params">(keyValue.getValue<span class="params">()</span>)</span>)</span>.append<span class="params">(<span class="string">"  "</span>)</span>.append<span class="params">(
                        new Date<span class="params">(keyValue.getTimestamp<span class="params">()</span>)</span>.toLocaleString<span class="params">()</span>)</span>;
                System.out.println<span class="params">(sb.toString<span class="params">()</span>)</span>;
            }

            <span class="comment">//这是另外一种获取返回结果的方式, 这种在Scan的返回多个Result的时候</span>
            <span class="comment">// 相对实用, 一个rowkey的都在一起, 一个ColumnFamily的也聚合在一起</span>
            NavigableMap&lt;byte[], NavigableMap&lt;byte[], NavigableMap&lt;Long, byte[]&gt;&gt;&gt; nMap = result.getMap<span class="params">()</span>;
            <span class="keyword">for</span> <span class="params">(Map.Entry&lt;byte[], NavigableMap&lt;byte[], NavigableMap&lt;Long, byte[]&gt;&gt;&gt; entry:nMap.entrySet<span class="params">()</span> )</span> {
                <span class="comment">//entry.getKey()为family key</span>
                String family = Bytes.toString<span class="params">(entry.getKey<span class="params">()</span>)</span>;
                System.out.print<span class="params">(family+<span class="string">":"</span>)</span>;
                <span class="keyword">for</span> <span class="params">(Map.Entry&lt;byte[], NavigableMap&lt;Long, byte[]&gt;&gt; entry2 : entry.getValue<span class="params">()</span>.entrySet<span class="params">()</span> )</span> {
                    <span class="comment">// entry2.getKey()为qualifier  当然qualifier有可能为空  这个不是问题  但为null的只能有一个</span>
                    String qualifier = Bytes.toString<span class="params">(entry2.getKey<span class="params">()</span>)</span>;
                    System.out.print<span class="params">(qualifier+<span class="string">"--:"</span>)</span>;
                    <span class="keyword">for</span> <span class="params">(Map.Entry&lt;Long, byte[]&gt; entry3:entry2.getValue<span class="params">()</span>.entrySet<span class="params">()</span> )</span> {
                        <span class="comment">//entry3.getKey()为 timestamp  entry3.getValue()为 value</span>
                        System.out.print<span class="params">(Bytes.toString<span class="params">(entry3.getValue<span class="params">()</span>)</span>+<span class="string">" "</span>
                                +new Date<span class="params">(entry3.getKey<span class="params">()</span>)</span>.toLocaleString<span class="params">()</span>)</span>;
                    }
                }
            }
            System.out.println<span class="params">(<span class="string">"------------------"</span>)</span>;
            <span class="comment">//Get的批处理类似于 SQL中的in操作,但操作起来也相当的简单, 和上面</span>
            <span class="comment">// 的Put Delete非常类似,也可以混合使用</span>
            List&lt;Row&gt; rows = new ArrayList&lt;Row&gt;<span class="params">()</span>;
            rows.add<span class="params">(new Get<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-10"</span>)</span>)</span>)</span>;
            rows.add<span class="params">(new Get<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-11"</span>)</span>)</span>)</span>;
            rows.add<span class="params">(new Put<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-1222221"</span>)</span>)</span>)</span>;
            try {
                Object[] objs = table.batch<span class="params">(rows)</span>;
                <span class="keyword">for</span> <span class="params">(Object obj : objs)</span> {
                    printKeyValue<span class="params">(<span class="params">(Result)</span>obj)</span>;
                }
            } catch <span class="params">(InterruptedException e)</span> {
                e.printStackTrace<span class="params">()</span>;
            }

        } catch <span class="params">(IOException e)</span> {
            e.printStackTrace<span class="params">()</span>;
        }
        <span class="comment">/**
         * Get获取单个 或随机的几个row 使用起来非常方便, 对于访问多个连续的row
         * 使用下面将要介绍的Scan操作,通常情况下, 完成一个业务 需要多个操作, 而
         * ORM无法将一个业务所有的操作SQL封装在一起, 除非直接使用JDBC
         * Hbase的这种 Put Get Delete 是不是很棒 , 对了没有Update, update的就
         * 是新增一条, 由于有版本, 旧的不会被立即淘汰掉
         */</span>
    }

    public void printKeyValue<span class="params">(Result result)</span>{
        List&lt;KeyValue&gt; values = result.list<span class="params">()</span>;
        <span class="comment">//由于KeyValue靠近底层, 对于一些一些Offset,Length结尾的方法 可以忽略,</span>
        <span class="comment">// 比较感兴趣的可以关注下Hbase的底层存储</span>
        <span class="keyword">for</span> <span class="params">(KeyValue keyValue : values)</span> {
            StringBuilder sb = new StringBuilder<span class="params">(Bytes.toString<span class="params">(keyValue.getFamily<span class="params">()</span>)</span>)</span>;
            sb.append<span class="params">(<span class="string">":"</span>)</span>.append<span class="params">(Bytes.toString<span class="params">(keyValue.getQualifier<span class="params">()</span>)</span>)</span>.append<span class="params">(<span class="string">"--:"</span>)</span>;
            sb.append<span class="params">(Bytes.toString<span class="params">(keyValue.getValue<span class="params">()</span>)</span>)</span>.append<span class="params">(<span class="string">"  "</span>)</span>.append<span class="params">(
                    new Date<span class="params">(keyValue.getTimestamp<span class="params">()</span>)</span>.toLocaleString<span class="params">()</span>)</span>;
            System.out.println<span class="params">(sb.toString<span class="params">()</span>)</span>;
        }
    }

    <span class="comment">/**
     * 对于连续记录的顺序访问  就是类似于 最常见的Select操作
     * 实际上Scan 非常类似于Hibernate 的DetachedCriteria, 而scan 使用的Filter就相当于Criteria的Expression或Restrictions
     * 可以实现离线封装查询条件   这个是相当的给力啊
     */</span>
    @Test public void ScanTest<span class="params">()</span>{
        ResultScanner resultScanner = null;
        try {
            <span class="comment">/**
             * 如Scan的名字, Scan是在一定的范围内startkey(StartRow)和endkey(StopRow)
             * 之间 顺序的扫描, 配合Filter 可以跳过不满足条件的记录  返回需要的结果
             * 当然startkey和endkey只是标识一个范围, 它们对应的rowkey可能并不存在,
             * 但如果存在(startkey) 扫描的范围是[startkey,endkey),否则就是(startkey,endkey)
             * 可以看到 Scan 有一个包裹Get的构造, 可以利用该get的rowkey作为startkey
             */</span>
            Scan scan  = new Scan<span class="params">()</span>;

            <span class="comment">/**
             * ResultScanner 就是table scanner返回的结果集, 类似于游标 可以迭代获取结果,
             * batch 就是每次迭代从服务器获取的记录数, 设置太小 会频繁到服务器取数据,
             * 太大 会对客户端造成比较大的压力,  具体根据需要使用 , 正常使用可以不必管
             * 它, 大批量读取可以考虑用它改善性能
             * 这里要注意了： 这个记录数是qualifier不是row, 如果一个row有17个qualifier,
             * setBatch(5),一个row就会分散到4个Result中, 分别持有5,5,5,2个qualifier
             * （默认一个row的所有qualifier会在一个Result中）
             *
             * ColumnPaginationFilter 对于一个Row会在一个Result 但是只返回前面一部分
             *
             * 如果使用FirstKeyOnlyFilter等 不是扫描Row全部的Filter 会有冲突 会有异常抛出 */</span>
            scan.setBatch<span class="params">(<span class="number">10</span>)</span>;
            <span class="comment">/**发给scanners的缓存的Row的数量, 如果没有设置会使用 HTable#getScannerCaching()的值
             * 一般 越大 Scan速度越快, 但消耗的内存也越大*/</span>
            scan.setCaching<span class="params">(<span class="number">10</span>)</span>;
            <span class="comment">//简而言之就是  batch 是qualifier column级别的   caching是row级别的</span>

            <span class="comment">//RegionServer是否应当缓存 当前客户端访问过的数据块    如果是随机的get 这个最好为false</span>
            scan.setCacheBlocks<span class="params">(<span class="literal">true</span>)</span>;

            <span class="comment">/** Scan 最复杂, 也最有用的就是Filter, 特别是FilterList对Filter进行的组合
             * 这里只先介绍Scan的其他参数 ;对于Filter,后面会单独介绍*/</span>

            <span class="comment">//startrow和stoprow 可以改变</span>
            scan.setStartRow<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-12"</span>)</span>)</span>;
            scan.setStopRow<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"row-1110"</span>)</span>)</span>;
            scan.setMaxVersions<span class="params">(<span class="number">3</span>)</span>;<span class="comment">//同Get</span>
            <span class="comment">/** 可以指定一个时间范围, 扫描指定时间或时间范围的的记录,  */</span>
            scan.setTimeRange<span class="params">(System.currentTimeMillis<span class="params">()</span>-<span class="number">1000000</span>, System.currentTimeMillis<span class="params">()</span>)</span>;
            <span class="comment">/**
             * 也可以指定timestamp 查询
             */</span>
            scan.setTimeStamp<span class="params">(System.currentTimeMillis<span class="params">()</span>)</span>;

            <span class="comment">/**可以使用Get中类似的方法 来限制获取的ColumnFamily Column*/</span>
            scan.addColumn<span class="params">(Bytes.toBytes<span class="params">(<span class="string">""</span>)</span>,Bytes.toBytes<span class="params">(<span class="string">""</span>)</span>)</span>;

            <span class="comment">//Scan中使用最多的还是Filter</span>
            HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
            <span class="comment">//看下面</span>
            table.setScannerCaching<span class="params">(<span class="number">1000</span>)</span>;
            resultScanner = table.getScanner<span class="params">(scan)</span>;
            <span class="comment">//这是foreach格式    是调用resultScanner.next()的</span>
            <span class="comment">//默认情况下  每次调用next() 都要RPC一下服务器   每个row一次, 即时resultScanner(int nbRows)</span>
            <span class="comment">//table.setScannerCaching() 默认是1  可以手工设置  设置后 该table实例的所有scan都有效</span>
            <span class="comment">//也可以每个scan单设置定就是上面有说过的scan.setCaching(1024*10); 这个会覆盖table设置的值</span>
            <span class="keyword">for</span> <span class="params">(Result result : resultScanner)</span> {
                <span class="comment">//这里就不多说了   和Get中一样的解析</span>
            }

        } catch <span class="params">(IOException e)</span> {
            e.printStackTrace<span class="params">()</span>;
        }finally{
            <span class="comment">//这样一定要记住 用完close</span>
            <span class="keyword">if</span><span class="params">(resultScanner!=null)</span>resultScanner.close<span class="params">()</span>;
        }

    }

    <span class="comment">/**
     * 高级的Scan,就是Filter中的FilterList  可以组合各个Filter
     * select cf1.column1,cf2.column2* from table_name where rowkey&gt;10 or value like 'xxx%' limit 10
     * 如果上面的SQL解析出来 and 表示MUST_PASS_ALL, or 表示MUST_PASS_ONE
     * 就是下面这个样(虽然理解可能不同,但下图的代码如下：)
     *  ( (cf1 and column1) or (cf2 and column2*)  ) and (rowkey&gt;10 or value like 'xxx%')
     * setFilter(
     *                                                        -ColumnFamilyFilter  cf1
     *                                     -filterList(ALL)--|
     *                                    |                   -ColumnFilter   column1
     *                  -filterList(ONE)-&gt;|
     *                 |                  |                   -ColumnFamilyFilter cf2
     *                 |                   -filterList(ALL)--|
     *                 |                                      -ColumnPrefixFilter column2
     *filterList(ALL)-&gt;|                -RowFilter 10
     *                 |-filterList(ONE)-&gt;|
     *                 |                   -ValueFilter xx
     *                  -PageFilter 10
     * @author Administrator
     *
     */</span>
    @Test public void scanAdvance<span class="params">()</span>{
        Scan scan  = new Scan<span class="params">()</span>;
        List&lt;Filter&gt; rootList = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
            List&lt;Filter&gt; selectList = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
                List&lt;Filter&gt; select_1 = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
                    select_1.add<span class="params">(new FamilyFilter<span class="params">(CompareFilter.CompareOp.EQUAL,
                            new BinaryComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"cf1"</span>)</span>)</span>)</span>)</span>;
                    select_1.add<span class="params">(new QualifierFilter<span class="params">(CompareFilter.CompareOp.EQUAL,
                            new BinaryComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"column1"</span>)</span>)</span>)</span>)</span>;
                List&lt;Filter&gt; select_2 = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
                    select_2.add<span class="params">(new FamilyFilter<span class="params">(CompareFilter.CompareOp.EQUAL,
                            new BinaryComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"cf2"</span>)</span>)</span>)</span>)</span>;
                    select_2.add<span class="params">(new QualifierFilter<span class="params">(CompareFilter.CompareOp.EQUAL,
                            new BinaryPrefixComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"column"</span>)</span>)</span>)</span>)</span>;
            selectList.add<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ALL, select_1)</span>)</span>;
            selectList.add<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ALL, select_2)</span>)</span>;
        rootList.add<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ONE,selectList)</span>)</span>;

            List&lt;Filter&gt; whereList = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
                whereList.add<span class="params">(new RowFilter<span class="params">(CompareFilter.CompareOp.GREATER,
                        new BinaryComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="number">10</span>)</span>)</span>)</span>)</span>;
                whereList.add<span class="params">(new RowFilter<span class="params">(CompareFilter.CompareOp.EQUAL,
                        new BinaryPrefixComparator<span class="params">(Bytes.toBytes<span class="params">(<span class="string">"xxx"</span>)</span>)</span>)</span>)</span>;
        rootList.add<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ONE,whereList)</span>)</span>;
        scan.setFilter<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ALL, rootList)</span>)</span>;
        <span class="comment">//这样的嵌套 写起来着实很烦, 可以自己封装成程序</span>
    }

    <span class="comment">/**
     * 一个不得不说的操作  分页操作, 
     * RDBMS 比如mysql :select * from table_name where sss=sss limit 1 10;
     * oracle 利用rownum也可以迂回实现,
     * Hbase这方面支持的不是太好, 也可以支持翻页
     */</span>
    @Test public void pageTest<span class="params">()</span>{
        <span class="comment">//与传统的分页的不同  start 是个起始的row  而不是一个数字 ,   下一页 的时候</span>
        <span class="comment">// 需要将上一页的最后一条记录作为分页条件传回来</span>
        <span class="comment">//这个start要是byte[],页面上只能暂时保存字符串  怎么办呢？？</span>
        <span class="comment">//Bytes.toStringBinary(byte[])与Bytes.toBytesBinary(String) 可以完美的实现字符串和byte[]的相互转换</span>
        <span class="comment">// Bytes.toStringBinary(Bytes.toBytesBinary("abc")) equals "abc" 是true</span>
        byte[] start = Bytes.toBytes<span class="params">(<span class="string">"row-13"</span>)</span>;
        int limit = <span class="number">10</span>;
        Scan scan = new Scan<span class="params">()</span>;
        scan.setStartRow<span class="params">(start)</span>;

        List&lt;Filter&gt; rootList = new ArrayList&lt;Filter&gt;<span class="params">()</span>;
        rootList.add<span class="params">(new PageFilter<span class="params">(limit)</span>)</span>;
        <span class="comment">////root.add(new Filter()) 添加其他的过滤条件</span>

        scan.setFilter<span class="params">(new FilterList<span class="params">(Operator.MUST_PASS_ALL, rootList)</span>)</span>;
    }

    <span class="comment">/**除了上面用到的
     * Htable 还有一些其他的有用方法
     * @throws IOException
     */</span>
    @SuppressWarnings<span class="params">(<span class="string">"unused"</span>)</span>
    @Test public void htableOthers<span class="params">()</span> throws IOException{
        HTable table = <span class="params">(HTable)</span>pool.getTable<span class="params">(<span class="string">"user_test_xuyang"</span>)</span>;
        byte [] row = Bytes.toBytes<span class="params">(<span class="string">"row-13"</span>)</span>;
        <span class="comment">//获取指定row的 数据所在的Region的信息 ：名字, 编码后名字(Hadoop 中的</span>
        <span class="comment">// 路径名), startKey endkey等---&gt;hri  ；还有该Region所在的主机的地址信息---&gt;addr</span>
        HRegionLocation hrl = table.getRegionLocation<span class="params">(row)</span>;
        HRegionInfo hri= hrl.getRegionInfo<span class="params">()</span>;
        HServerAddress addr = hrl.getServerAddress<span class="params">()</span>;

        <span class="comment">//获取所有Region的信息</span>
        Map&lt;HRegionInfo,HServerAddress&gt; regions = table.getRegionsInfo<span class="params">()</span>;

        <span class="comment">//获取该表所在的所有Region的  startKey 和 endKey</span>
        Pair&lt;byte[][], byte[][]&gt; startendKeys = table.getStartEndKeys<span class="params">()</span>;
        <span class="comment">//下面的是通过上面的实现的</span>
        table.getStartKeys<span class="params">()</span>;
        table.getEndKeys<span class="params">()</span>;

        <span class="comment">//table.getRowOrBefore(row, family) 这个一般用不到  0.92时候 就要被废弃了</span>
    }

    <span class="comment">/**
     * 操作完成后, 清理下资源还是很有必要的,
     * 在系统的ServletContextListener
     */</span>
    @AfterClass
    public static void after<span class="params">()</span>{
        try {
            <span class="keyword">if</span><span class="params">(conf!=null)</span> HConnectionManager.deleteConnection<span class="params">(conf, <span class="literal">false</span>)</span>;
            <span class="keyword">if</span><span class="params">(pool!=null)</span>pool.close<span class="params">()</span>;
        } catch <span class="params">(IOException e)</span> {
            e.printStackTrace<span class="params">()</span>;
        }
    }
}
        <span class="comment">// 路径名), startKey endkey等---&gt;hri  ；还有该Region所在的主机的地址信息---&gt;addr</span>
        HRegionLocation hrl = table.getRegionLocation<span class="params">(row)</span>;
        HRegionInfo hri= hrl.getRegionInfo<span class="params">()</span>;
        HServerAddress addr = hrl.getServerAddress<span class="params">()</span>;

        <span class="comment">//获取所有Region的信息</span>
        Map&lt;HRegionInfo,HServerAddress&gt; regions = table.getRegionsInfo<span class="params">()</span>;

        <span class="comment">//获取该表所在的所有Region的  startKey 和 endKey</span>
        Pair&lt;byte[][], byte[][]&gt; starten
</code></pre>
      
      


    </div>
    
    <footer class="article-footer">
      
        <a data-url="http://liuziquan.github.io/2015/09/11/HBase入门实例/" data-id="cief7ww300000d4mkynzgveyl" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HBase/">HBase</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HBase简单Java代码示例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/11/HBase简单Java代码示例/" class="article-date">
  <time datetime="2015-09-10T16:00:00.000Z" itemprop="datePublished">2015-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/HBase/">HBase</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/11/HBase简单Java代码示例/">HBase简单Java代码示例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      

<!-- Table of Contents -->


        <p>这里我们用一个学生成绩表作为例子,对HBase的基本操作和基本概念进行讲解:<br>下面是学生的成绩表:</p>
<table>
<thead>
<tr>
<th>name</th>
<th>grade</th>
<th>course:math</th>
<th>course:art</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tom</td>
<td>1</td>
<td>87</td>
<td>97</td>
</tr>
<tr>
<td>Jerry</td>
<td>2</td>
<td>100</td>
<td>80</td>
</tr>
</tbody>
</table>
<p>这里grade对于表来说是一个列,course对于表来说是一个列族,这个列族由两个列组成:math和art,<br>当然我们可以根据我们的需要在course中建立更多的列族,如computer,physics等相应的列添加入course列族.<br>有了上面的想法和需求,我们就可以在HBase中建立相应的数据表啦!</p>
<ol>
<li><p>建立一个表格 scores 具有两个列族grade 和courese</p>
<pre><code><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">002</span>:<span class="number">0</span>&gt; create <span class="string">'scores'</span>, <span class="string">'grade'</span>, <span class="string">'course'</span>
<span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">4.1610</span> seconds
</code></pre></li>
<li><p>查看当先HBase中具有哪些表</p>
<pre><code><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">003</span>:<span class="number">0</span>&gt; list
scores
<span class="number">1</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.0210</span> seconds
</code></pre></li>
<li><p>查看表的构造</p>
<pre><code>hbase(main):<span class="number">004</span>:<span class="number">0</span>&gt; describe <span class="string">'scores'</span>
{NAME =&gt; <span class="string">'scores'</span>, IS_ROOT =&gt; <span class="string">'false'</span>, IS_META =&gt; <span class="string">'false'</span>, FAMILIES =&gt; [{NAME =&gt; <span class="string">'course'</span>, BLOOMFILTER =&gt; <span class="string">'false'</span>, IN_MEMORY =&gt; <span class="string">'false'</span>, LENGTH =&gt; <span class="string">'2147483647'</span>, BLOCKCACHE =&gt; <span class="string">'false'</span>, VERSIONS =&gt; <span class="string">'3'</span>, TTL =&gt; <span class="string">'-1'</span>, COMPRESSION =&gt; <span class="string">'NONE'</span>}, {NAME =&gt; <span class="string">'grade'</span>, BLOOMFILTER =&gt; <span class="string">'false'</span>, IN_MEMORY =&gt; <span class="string">'false'</span>, LENGTH =&gt; <span class="string">'2147483647'</span>, BLOCKCACHE =&gt; <span class="string">'false'</span>, VERSIONS =&gt; <span class="string">'3'</span>, TTL =&gt; <span class="string">'-1'</span>, COMPRESSION =&gt; <span class="string">'NONE'</span>}]}
<span class="number">1</span> row(s) <span class="keyword">in</span> <span class="number">0.0130</span> seconds
</code></pre></li>
<li><p>加入一行数据,行名称为 Tom 列族grad的列名为”” 值位1</p>
<pre><code><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">005</span>:<span class="number">0</span>&gt; put <span class="string">'scores'</span>, <span class="string">'Tom'</span>, <span class="string">'grade:'</span>, <span class="string">'1'</span>
<span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.0070</span> seconds
</code></pre></li>
<li><p>给Tom这一行的数据的列族添加一列</p>
<pre><code><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">006</span>:<span class="number">0</span>&gt; put <span class="string">'scores'</span>, <span class="string">'Tom'</span>, <span class="string">'course:math'</span>, <span class="string">'87'</span>
<span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.0040</span> seconds
</code></pre></li>
<li><p>给Tom这一行的数据的列族添加一列</p>
<pre><code><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">007</span>:<span class="number">0</span>&gt; put <span class="string">'scores'</span>, <span class="string">'Tom'</span>, <span class="string">'course:art'</span>, <span class="string">'97'</span>
<span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.0030</span> seconds
</code></pre></li>
<li><p>加入一行数据,行名称为 Jerry 列族grad的列名为”” 值位2</p>
<pre><code><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">008</span>:<span class="number">0</span>&gt; put <span class="string">'scores'</span>, <span class="string">'Jerry'</span>, <span class="string">'grade:'</span>, <span class="string">'2'</span>
<span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.0040</span> seconds
</code></pre></li>
<li><p>给Jerry这一行的数据的列族添加一列</p>
<pre><code><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">009</span>:<span class="number">0</span>&gt; put <span class="string">'scores'</span>, <span class="string">'Jerry'</span>, <span class="string">'course:math'</span>, <span class="string">'100'</span>
<span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.0030</span> seconds
</code></pre></li>
<li><p>给Jerry这一行的数据的列族添加一列</p>
<pre><code><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">010</span>:<span class="number">0</span>&gt; put <span class="string">'scores'</span>, <span class="string">'Jerry'</span>, <span class="string">'course:art'</span>, <span class="string">'80'</span>
<span class="number">0</span> <span class="function"><span class="title">row</span><span class="params">(s)</span></span> <span class="keyword">in</span> <span class="number">0.0050</span> seconds
</code></pre></li>
<li><p>查看scores表中Tom的相关数据</p>
<pre><code>hbase(main):011:<span class="operator">0&gt; <span class="keyword">get</span> <span class="string">'scores'</span>, <span class="string">'Tom'</span>
<span class="keyword">COLUMN</span>                       CELL
course:art                  <span class="keyword">timestamp</span>=<span class="number">1224726394286</span>, <span class="keyword">value</span>=<span class="number">97</span>
course:math                 <span class="keyword">timestamp</span>=<span class="number">1224726377027</span>, <span class="keyword">value</span>=<span class="number">87</span>
grade:                      <span class="keyword">timestamp</span>=<span class="number">1224726360727</span>, <span class="keyword">value</span>=<span class="number">1</span>
<span class="number">3</span> <span class="keyword">row</span>(s) <span class="keyword">in</span> <span class="number">0.0070</span> seconds</span>
</code></pre></li>
<li><p>查看scores表中所有数据</p>
<pre><code>hbase(main):012:0&gt; scan 'scores'
ROW                          COLUMN+CELL
Tom                         column=course:art, timestamp=1224726394286, value=97
Tom                         column=course:math, timestamp=1224726377027, value=87
Tom                         column=grade:, timestamp=1224726360727, value=1
Jerry                        column=course:art, timestamp=1224726424967, value=80
Jerry                        column=course:math, timestamp=1224726416145, value=100
Jerry                        column=grade:, timestamp=1224726404965, value=2
6 row(s) in 0.0410 seconds
</code></pre></li>
<li><p>查看scores表中所有数据courses列族的所有数据</p>
<pre><code>hbase(main):013:<span class="operator">0&gt; <span class="keyword">scan</span> <span class="string">'scores'</span>,{<span class="keyword">COLUMN</span>=&gt;[<span class="string">'course'</span>]}        
<span class="keyword">ROW</span>                                      <span class="keyword">COLUMN</span>+CELL                                                                                                        
 Jerry                                   <span class="keyword">column</span>=course:art, <span class="keyword">timestamp</span>=<span class="number">1441953970540</span>, <span class="keyword">value</span>=<span class="number">80</span>                                                               
 Jerry                                   <span class="keyword">column</span>=course:math, <span class="keyword">timestamp</span>=<span class="number">1441953959676</span>, <span class="keyword">value</span>=<span class="number">100</span>                                                             
 Tom                                     <span class="keyword">column</span>=course:art, <span class="keyword">timestamp</span>=<span class="number">1441953935469</span>, <span class="keyword">value</span>=<span class="number">97</span>                                                               
 Tom                                     <span class="keyword">column</span>=course:math, <span class="keyword">timestamp</span>=<span class="number">1441953923125</span>, <span class="keyword">value</span>=<span class="number">87</span>                                                              
<span class="number">2</span> <span class="keyword">row</span>(s) <span class="keyword">in</span> <span class="number">0.0640</span> seconds</span>
</code></pre></li>
</ol>
<p>上面就是HBase的基本shell操作的一个例子,可以看出,hbase的shell还是比较简单易用的,<br>从中也可以看出HBase shell缺少很多传统sql中的一些类似于like等相关操作,<br>当然,HBase作为BigTable的一个开源实现,而BigTable是作为 google业务的支持模型,<br>很多sql语句中的一些东西可能还真的不需要.<br>当然,通过程序我们也可以对HBase进行相关的操作.下面的程序就完成了上面shell操作的内容:</p>
<pre><code><span class="built_in">import</span> java.io.IOException;
<span class="built_in">import</span> java.io.ByteArrayOutputStream;
<span class="built_in">import</span> java.io.DataOutputStream;
<span class="built_in">import</span> java.io.ByteArrayInputStream;
<span class="built_in">import</span> java.io.DataInputStream;
<span class="built_in">import</span> java.util.Map;
<span class="built_in">import</span> org.apache.hadoop.io.Writable;
<span class="built_in">import</span> org.apache.hadoop.io.IntWritable;
<span class="built_in">import</span> org.apache.hadoop.hbase.HBaseConfiguration;
<span class="built_in">import</span> org.apache.hadoop.hbase.HTableDescriptor;
<span class="built_in">import</span> org.apache.hadoop.hbase.HColumnDescriptor;
<span class="built_in">import</span> org.apache.hadoop.hbase.client.HBaseAdmin;
<span class="built_in">import</span> org.apache.hadoop.hbase.client.HTable;
<span class="built_in">import</span> org.apache.hadoop.hbase.io.BatchUpdate;
<span class="built_in">import</span> org.apache.hadoop.hbase.io.RowResult;
<span class="built_in">import</span> org.apache.hadoop.hbase.io.Cell;
<span class="built_in">import</span> org.apache.hadoop.hbase.util.Writables;
public class HBaseBasic {
    public static void main<span class="params">(String[] args)</span> throws Exception {
        HBaseConfiguration config = new HBaseConfiguration<span class="params">()</span>;
        HBaseAdmin admin = new HBaseAdmin<span class="params">(config)</span>;
        <span class="keyword">if</span> <span class="params">(admin.tableExists<span class="params">(<span class="string">"scores"</span>)</span>)</span> {
            System.out.println<span class="params">(<span class="string">"drop table"</span>)</span>;
            admin.disableTable<span class="params">(<span class="string">"scores"</span>)</span>;
            admin.deleteTable<span class="params">(<span class="string">"scores"</span>)</span>;
        }

        System.out.println<span class="params">(<span class="string">"create table"</span>)</span>;
        HTableDescriptor tableDescripter = new HTableDescriptor<span class="params">(<span class="string">"scores"</span>.getBytes<span class="params">()</span>)</span>;
        tableDescripter.addFamily<span class="params">(new HColumnDescriptor<span class="params">(<span class="string">"grade:"</span>)</span>)</span>;
        tableDescripter.addFamily<span class="params">(new HColumnDescriptor<span class="params">(<span class="string">"course:"</span>)</span>)</span>;
        admin.createTable<span class="params">(tableDescripter)</span>;
        HTable table = new HTable<span class="params">(config, <span class="string">"scores"</span>)</span>;

        System.out.println<span class="params">(<span class="string">"add Tom's data"</span>)</span>;
        BatchUpdate tomUpdate = new BatchUpdate<span class="params">(<span class="string">"Tom"</span>)</span>;
        tomUpdate.put<span class="params">(<span class="string">"grade:"</span>, Writables.getBytes<span class="params">(new IntWritable<span class="params">(<span class="number">1</span>)</span>)</span>)</span>;
        tomUpdate.put<span class="params">(<span class="string">"course:math"</span>, Writables.getBytes<span class="params">(new IntWritable<span class="params">(<span class="number">87</span>)</span>)</span>)</span>;
        tomUpdate.put<span class="params">(<span class="string">"course:art"</span>, Writables.getBytes<span class="params">(new IntWritable<span class="params">(<span class="number">97</span>)</span>)</span>)</span>;
        table.commit<span class="params">(tomUpdate)</span>;

        System.out.println<span class="params">(<span class="string">"add Jerry's data"</span>)</span>;
        BatchUpdate jerryUpdate = new BatchUpdate<span class="params">(<span class="string">"Jerry"</span>)</span>;
        jerryUpdate.put<span class="params">(<span class="string">"grade:"</span>, Writables.getBytes<span class="params">(new IntWritable<span class="params">(<span class="number">2</span>)</span>)</span>)</span>;
        jerryUpdate.put<span class="params">(<span class="string">"course:math"</span>, Writables.getBytes<span class="params">(new IntWritable<span class="params">(<span class="number">100</span>)</span>)</span>)</span>;
        jerryUpdate.put<span class="params">(<span class="string">"course:art"</span>, Writables.getBytes<span class="params">(new IntWritable<span class="params">(<span class="number">80</span>)</span>)</span>)</span>;
        table.commit<span class="params">(jerryUpdate)</span>;
        <span class="keyword">for</span> <span class="params">(RowResult row : table.getScanner<span class="params">(new String[] { <span class="string">"course:"</span> })</span>)</span> {
            System.out.format<span class="params">(<span class="string">"ROW\t%s\n"</span>, new String<span class="params">(row.getRow<span class="params">()</span>)</span>)</span>;
            <span class="keyword">for</span> <span class="params">(Map.Entry&lt;byte[], Cell&gt; entry : row.entrySet<span class="params">()</span>)</span> {
                String column = new String<span class="params">(entry.getKey<span class="params">()</span>)</span>;
                Cell cell = entry.getValue<span class="params">()</span>;
                IntWritable value = new IntWritable<span class="params">()</span>;
                Writables.copyWritable<span class="params">(cell.getValue<span class="params">()</span>, value)</span>;
                System.out.format<span class="params">(<span class="string">" COLUMN\t%s\t%d\n"</span>, column, value.get<span class="params">()</span>)</span>;
            }
        }
    }
}
</code></pre><p>输出如下:</p>
<pre><code><span class="operator"><span class="keyword">drop</span> <span class="keyword">table</span>
<span class="number">09</span>/<span class="number">07</span>/<span class="number">11</span> <span class="number">08</span>:<span class="number">51</span>:<span class="number">59</span> INFO <span class="keyword">client</span>.HBaseAdmin: Disabled scores
<span class="number">09</span>/<span class="number">07</span>/<span class="number">11</span> <span class="number">08</span>:<span class="number">51</span>:<span class="number">59</span> INFO <span class="keyword">client</span>.HBaseAdmin: Deleted scores
<span class="keyword">create</span> <span class="keyword">table</span>
<span class="keyword">add</span> Tom<span class="string">'s data
add Jerry'</span>s <span class="keyword">data</span>
<span class="keyword">ROW</span>     Tom
  <span class="keyword">COLUMN</span>        course:art      <span class="number">97</span>
  <span class="keyword">COLUMN</span>        course:math     <span class="number">87</span>
<span class="keyword">ROW</span>     Jerry
  <span class="keyword">COLUMN</span>        course:art      <span class="number">80</span>
  <span class="keyword">COLUMN</span>        course:math     <span class="number">100</span></span>
</code></pre>
      
      


    </div>
    
    <footer class="article-footer">
      
        <a data-url="http://liuziquan.github.io/2015/09/11/HBase简单Java代码示例/" data-id="ciefazop400006kmk4v39lbe8" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HBase/">HBase</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HBase应用之Table设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/11/HBase应用之Table设计/" class="article-date">
  <time datetime="2015-09-10T16:00:00.000Z" itemprop="datePublished">2015-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/HBase/">HBase</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/11/HBase应用之Table设计/">HBase应用之Table设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      

<!-- Table of Contents -->


        <h3 id="HBase基本类型定义">HBase基本类型定义</h3><ul>
<li>Table：表 </li>
<li>RowKey：行健，主键</li>
<li>Column Family：列族，包含一个或者多个相关列</li>
<li>Column：属于某一个columnfamily，familyName:columnName，每条记录可动态添加</li>
<li>timestamp：每次操作对应的时间戳，支持用户自定义，默认为当前时间的毫秒值</li>
<li>value：值，和timestamp一起支持多version的概念</li>
</ul>
<p>通过HBase Shell可以拿到一条数据，如下：</p>
<pre><code>hbase(main):029:<span class="operator">0&gt; <span class="keyword">scan</span> <span class="string">'scores'</span>,{<span class="keyword">LIMIT</span>=&gt;<span class="number">1</span>}
<span class="keyword">ROW</span>                                      <span class="keyword">COLUMN</span>+CELL                                                                                                        
 Jerry                                   <span class="keyword">column</span>=course:art, <span class="keyword">timestamp</span>=<span class="number">1441953970540</span>, <span class="keyword">value</span>=<span class="number">80</span>                                                               
 Jerry                                   <span class="keyword">column</span>=course:math, <span class="keyword">timestamp</span>=<span class="number">1441953959676</span>, <span class="keyword">value</span>=<span class="number">100</span>                                                             
 Jerry                                   <span class="keyword">column</span>=grade:, <span class="keyword">timestamp</span>=<span class="number">1441953949725</span>, <span class="keyword">value</span>=<span class="number">2</span>                                                                    
<span class="number">1</span> <span class="keyword">row</span>(s) <span class="keyword">in</span> <span class="number">0.0350</span> seconds</span>
</code></pre><p>对应内容：</p>
<pre><code><span class="setting">Jerry =<span class="value">》 RowKey</span></span>
<span class="setting">course =<span class="value">》 Column Family</span></span>
<span class="setting">column =<span class="value">》 art</span></span>
<span class="setting">timestamp =<span class="value">&gt; <span class="number">1441953970540</span></span></span>
<span class="setting">80  =<span class="value">&gt; value</span></span>
</code></pre><h3 id="HBase存储结构">HBase存储结构</h3><ol>
<li>HBase以表（HTable）的形式存储数据</li>
<li>HTable包括很多行，每行通过RowKey唯一标记，行按照RowKey的字典序排列，表在行的方向上分割为多个HRegion</li>
<li>每行包括一个RowKey和多个Column Family，数据按照Column Family进行物理切割，即不同Column Family的数据放在不同的Store中，一个Column Family放在一个Strore中</li>
<li>HRegion由多个Store组成。一个Store由物理上存在的一个MemStrore（内存中）和多个StoreFile（HFile）中</li>
</ol>
<h3 id="设计">设计</h3><p>从应用角度，有两点比较重要：</p>
<ol>
<li>HBase中RowKey是按照字典序排列的</li>
<li>不同Column Family的数据，在物理上是分开的</li>
</ol>
<p>在做table设计的时候，主要围绕上述两点做文章。<br>RowKey的设计需要根据请求数据特点：</p>
<ol>
<li>单个查询，需要尽量缩小Key的长度</li>
<li>范围查询，根据RowKey按字典序排列的特点，针对查询需求设计rowkey，保证范围查询的rowkey在物理上存放在一起</li>
</ol>
<p><strong>Column Family的设计需遵循：尽量避免一次请求需要拿到的Column分布在不同的Column Family中</strong></p>
<h3 id="实例">实例</h3><p>对于基于RowKey的范围查询设计，我们来看一个实例：</p>
<ol>
<li>给出userid，返回这个userid最近插入的N条数据 </li>
<li>给出userid，及一个时间区间，返回这个时间区间的N条数据</li>
</ol>
<p>针对需求，Key设计如下：</p>
<pre><code>Userid_DataTime_InertTime
Userid：即userid
DataTime：数据所属时间(ms)，定义为：Long<span class="class">.MAX_VALUE</span> - dataTime.<span class="function"><span class="title">getTime</span><span class="params">()</span></span>，由于RowKey字典序排列，可以使最近插入的数据排在前面，支持“最近插入的N条数据”的需求
InsertTime：数据入库时间(ns)，取nanotime（InsertTime的存在是由于在这个应用中，Userid+DataTime不能唯一定位一条数据）
</code></pre><p>Key生成代码如下：</p>
<pre><code><span class="comment">//生成RowKey  </span>
<span class="keyword">private</span> <span class="keyword">String</span> buildPutRowKey(<span class="built_in">int</span> userId, Date addTime) {  
        <span class="keyword">String</span> <span class="variable">key</span> = userId + <span class="string">"_"</span> + getRowKeyTimestamp(addTime) + <span class="string">"_"</span> + System.nanoTime();  
        <span class="keyword">return</span> <span class="variable">key</span>;  
}  

<span class="comment">//构建DataTime  </span>
<span class="keyword">private</span> <span class="keyword">long</span> getRowKeyTimestamp(Date addTime) {  
        <span class="keyword">return</span> Long.MAX_VALUE - addTime.getTime();  
}  
</code></pre>
      
      


    </div>
    
    <footer class="article-footer">
      
        <a data-url="http://liuziquan.github.io/2015/09/11/HBase应用之Table设计/" data-id="ciefdkoxh0000comkotlca4c5" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HBase/">HBase</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/02/hello-world/" class="article-date">
  <time datetime="2015-09-02T09:40:28.207Z" itemprop="datePublished">2015-09-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/02/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      

<!-- Table of Contents -->


        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
      


    </div>
    
    <footer class="article-footer">
      
        <a data-url="http://liuziquan.github.io/2015/09/02/hello-world/" data-id="ciefazopq00016kmksp8tfklh" class="article-share-link">分享到</a>
      

      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-Hexo轻量级使用指南" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/02/Hexo轻量级使用指南/" class="article-date">
  <time datetime="2015-09-01T16:00:00.000Z" itemprop="datePublished">2015-09-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hexo/">Hexo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/02/Hexo轻量级使用指南/">Hexo轻量级使用指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      

<!-- Table of Contents -->


        <h2 id="Hexo一句话说明">Hexo一句话说明</h2><p>hexo是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管在github和Heroku上。作者是来自台湾的@tommy351。引用@tommy351的话，hexo：</p>
<blockquote>
<p>快速、简单且功能强大的 Node.js 博客框架。<br>A fast, simple &amp; powerful blog framework, powered by Node.js.</p>
</blockquote>
<p>类似于jekyll、Octopress、Wordpress，我们可以用hexo创建自己的博客，托管到github或Heroku上，绑定自己的域名，用markdown写文章。</p>
<h2 id="Hexo在github上搭建个人Blog">Hexo在github上搭建个人Blog</h2><p>阅读以下推荐文章，可轻松完成。</p>
<h2 id="推荐阅读">推荐阅读</h2><p><a href="http://wowubuntu.com/markdown/#autolink" target="_blank" rel="external">Markdown 语法说明 (简体中文版)</a>[1]<br><a href="http://blog.fens.me/hexo-blog-github/" target="_blank" rel="external">Hexo在github上构建免费的Web应用</a>[2]<br><a href="http://zipperary.com/2013/05/28/hexo-guide-1/" target="_blank" rel="external">hexo系列教程：（一）hexo介绍</a>[3]<br><a href="http://zipperary.com/2013/05/28/hexo-guide-2/" target="_blank" rel="external">hexo系列教程：（二）搭建hexo博客</a>[4]<br><a href="http://zipperary.com/2013/05/29/hexo-guide-3/" target="_blank" rel="external">hexo系列教程：（三）hexo博客的配置、使用</a>[5]<br><a href="http://zipperary.com/2013/05/30/hexo-guide-4/" target="_blank" rel="external">hexo系列教程：（四）hexo博客的优化技巧</a>[6]<br><a href="http://zipperary.com/2013/06/02/hexo-guide-5/" target="_blank" rel="external">hexo系列教程：（五）hexo博客的优化技巧续</a>[7]<br><a href="https://help.github.com/articles/generating-ssh-keys/" target="_blank" rel="external">Generating SSH keys</a>[8]<br><a href="http://immmmm.com/hexo-using-record.html" target="_blank" rel="external">Hexo 使用记录</a>[9]<br><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo你的博客</a>[10]<br><a href="http://hexo-demo-d281b.coding.io/2014/12/04/hexo-demo/" target="_blank" rel="external">使用Cover主题，在Coding上搭建Hexo博客</a>[11]<br><a href="http://wiki.jikexueyuan.com/project/hexo-document/" target="_blank" rel="external">Hexo 中文版</a>[12]<br><a href="http://www.cnblogs.com/zhcncn/p/4097881.html" target="_blank" rel="external">Hexo搭建Github静态博客</a>[13]<br><a href="http://blog.lmintlcx.com/post/blog-with-hexo.html" target="_blank" rel="external">使用Hexo搭建博客</a>[14]<br><a href="http://opiece.me/2015/04/09/hexo-guide/" target="_blank" rel="external">使用Hexo搭建个人博客(基于hexo3.0)</a>[15]<br><a href="http://shijiajie.com/2015/08/29/hexo-theme-landscape-plus-optimize/" target="_blank" rel="external">Hexo官方主题landscape-plus优化</a>[16]</p>

      
      


    </div>
    
    <footer class="article-footer">
      
        <a data-url="http://liuziquan.github.io/2015/09/02/Hexo轻量级使用指南/" data-id="cief7vznm0000bomkzwnz2ol4" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/">Hexo</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">推荐文章</h3>
    <div class="widget">
      <ul>
        
        
          
          <li>
            <a href="http://shijiajie.com/2015/08/29/hexo-theme-landscape-plus-optimize/" target="_blank">1. Hexo官方主题landscape-plus优化</a>
          </li>
        
          
          <li>
            <a href="http://www.cnblogs.com/zhcncn/p/4097881.html" target="_blank">2. Hexo搭建Github静态博客</a>
          </li>
        
          
          <li>
            <a href="http://blog.fens.me/hexo-blog-github/" target="_blank">3. Hexo在github上构建免费的Web应用</a>
          </li>
        
          
          <li>
            <a href="http://blog.lmintlcx.com/post/blog-with-hexo.html" target="_blank">4. 使用Hexo搭建博客</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/DB2/" style="font-size: 15px;">DB2</a> <a href="/tags/HBase/" style="font-size: 20px;">HBase</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/DB2/">DB2</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/HBase/">HBase</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MongoDB/">MongoDB</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">2015年 09月</a><span class="archive-list-count">9</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://www.cnblogs.com/shi0090/" target="_blank">石佳劼的博客园</a>
          </li>
        
          <li>
            <a href="https://github.com/stone0090/" target="_blank">石佳劼的GitHub</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  </script>
  
  <div class="outer">
    <div id="footer-info" class="inner">
      Copyright &copy; 2012 - 2015 <a href="http://liuziquan.github.io/" target="_blank">liuziquan</a>.
    </div>
  </div>
</footer>

  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">文章</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->


<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
                processEscapes: true
                    
}
  
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
                  
}
    
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
            for(i=0; i < all.length; i += 1) {
                            all[i].SourceElement().parentNode.className += ' has-jax';
                                    
            }
                
        });
</script>

<script type="text/javascript" src="http://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<script src="/js/script.js" type="text/javascript"></script>

</div>
</body>
</html>
